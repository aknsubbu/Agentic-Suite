import json
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.gridspec import GridSpec
from matplotlib.ticker import FuncFormatter
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.patheffects as path_effects
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors as reportlab_colors
from reportlab.lib.units import inch
from reportlab.graphics.shapes import Drawing, Line
from reportlab.graphics.charts.linecharts import HorizontalLineChart
from reportlab.graphics.charts.barcharts import VerticalBarChart
from reportlab.platypus.flowables import Flowable
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT
from io import BytesIO
from datetime import datetime, timedelta
import logging
import traceback

# Set up logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    filename='logs/report_generator.log')
logger = logging.getLogger('ReportGenerator')

# Create a horizontal line class for PDF reports
class HorizontalLine(Flowable):
    """A horizontal line flowable with robust width handling."""
    
    def __init__(self, width=None, thickness=1, color=reportlab_colors.black, spaceBefore=0, spaceAfter=0):
        Flowable.__init__(self)
        self.width = width if width is not None else 6*inch  # Default width if None is provided
        self.thickness = thickness
        self.color = color
        self.spaceBefore = spaceBefore
        self.spaceAfter = spaceAfter
        
    def __repr__(self):
        return "HorizontalLine(width=%s)" % self.width
    
    def wrap(self, availWidth, availHeight):
        # Make sure we always return valid width and height
        width = min(self.width, availWidth) if self.width is not None else availWidth
        return width, self.thickness + 1
        
    def draw(self):
        # Ensure width is never None
        width = self.width if self.width is not None else 6*inch
        
        self.canv.setStrokeColor(self.color)
        self.canv.setLineWidth(self.thickness)
        self.canv.line(0, 0, width, 0)


class CreditBox(Flowable):
    """A box with credit information with robust width handling."""
    
    def __init__(self, width=None, height=0.5*inch, text="Generated by Stock Analyzer"):
        Flowable.__init__(self)
        self.width = width if width is not None else 6*inch  # Default width if None is provided
        self.height = height
        self.text = text
    
    def __repr__(self):
        return "CreditBox(width=%s, height=%s)" % (self.width, self.height)
    
    def wrap(self, availWidth, availHeight):
        # Make sure we always return valid width and height
        width = min(self.width, availWidth) if self.width is not None else availWidth
        return width, self.height
        
    def draw(self):
        # Ensure width is never None
        width = self.width if self.width is not None else 6*inch
        
        # Draw a rounded rectangle
        self.canv.setFillColor(reportlab_colors.lightgrey)
        self.canv.setStrokeColor(reportlab_colors.grey)
        self.canv.roundRect(0, 0, width, self.height, 5, fill=1, stroke=1)
        
        # Add text
        self.canv.setFillColor(reportlab_colors.darkblue)
        self.canv.setFont("Helvetica-Bold", 8)
        self.canv.drawCentredString(width/2, self.height/2 - 4, self.text)

# Credit box class for PDF reports
class CreditBox(Flowable):
    """A box with credit information."""
    
    def __init__(self, width=None, height=0.5*inch, text="Generated by Stock Analyzer"):
        Flowable.__init__(self)
        self.width = width
        self.height = height
        self.text = text
        
    def __repr__(self):
        return "CreditBox(width=%s, height=%s)" % (self.width, self.height)
        
    def draw(self):
        # Draw a rounded rectangle
        self.canv.setFillColor(reportlab_colors.lightgrey)
        self.canv.setStrokeColor(reportlab_colors.grey)
        self.canv.roundRect(0, 0, self.width or (self.canv._pagesize[0] - 2*inch), self.height, 5, fill=1, stroke=1)
        
        # Add text
        self.canv.setFillColor(reportlab_colors.darkblue)
        self.canv.setFont("Helvetica-Bold", 8)
        self.canv.drawCentredString((self.width or (self.canv._pagesize[0] - 2*inch))/2, self.height/2 - 4, self.text)

class StockReportGenerator:
    def __init__(self, ticker, output_dir="reports"):
        """Initialize the report generator for a specific ticker."""
        self.ticker = ticker.upper()
        self.output_dir = output_dir
        self.data = None
        self.report_date = datetime.now().strftime("%Y-%m-%d")
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Configure matplotlib for better visuals
        plt.style.use('seaborn-v0_8-whitegrid')
        plt.rcParams['figure.figsize'] = (10, 6)
        plt.rcParams['axes.labelsize'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.titleweight'] = 'bold'
        plt.rcParams['xtick.labelsize'] = 10
        plt.rcParams['ytick.labelsize'] = 10
        plt.rcParams['legend.fontsize'] = 10
        plt.rcParams['figure.titlesize'] = 16
        
        # Use a more professional color scheme
        self.color_primary = '#1A5276'  # Dark blue
        self.color_secondary = '#2874A6'  # Medium blue
        self.color_accent = '#3498DB'  # Light blue
        self.color_positive = '#27AE60'  # Green
        self.color_negative = '#C0392B'  # Red
        self.color_neutral = '#7F8C8D'  # Gray
        
        # Custom color maps for charts
        self.price_cmap = LinearSegmentedColormap.from_list('price_cmap', 
                                                            ['#D6EAF8', '#2874A6', '#1A5276'])
        self.volume_cmap = LinearSegmentedColormap.from_list('volume_cmap',
                                                             ['#D5F5E3', '#27AE60', '#196F3D'])
        
        # Create a logs directory if it doesn't exist
        os.makedirs('logs', exist_ok=True)
        
        # ReportLab styles
        self.styles = getSampleStyleSheet()
        
        # Title Style (Main title of the report)
        self.title_style = ParagraphStyle(
            'TitleStyle',
            parent=self.styles['Heading1'],
            fontSize=24,
            alignment=TA_CENTER,
            spaceAfter=30,
            textColor=reportlab_colors.HexColor(self.color_primary),
            leading=30
        )
        
        # Subtitle Style (Section headings)
        self.subtitle_style = ParagraphStyle(
            'SubtitleStyle',
            parent=self.styles['Heading2'],
            fontSize=18,
            spaceBefore=20,
            spaceAfter=10,
            textColor=reportlab_colors.HexColor(self.color_secondary),
            borderColor=reportlab_colors.HexColor(self.color_secondary),
            borderWidth=0,
            borderPadding=5,
            borderRadius=3,
            leading=24
        )
        
        # Section Style (Subsection headings)
        self.section_style = ParagraphStyle(
            'SectionStyle',
            parent=self.styles['Heading3'],
            fontSize=14,
            spaceBefore=15,
            spaceAfter=8,
            textColor=reportlab_colors.HexColor(self.color_secondary),
            leading=18
        )
        
        # Body Style (Main text content)
        self.body_style = ParagraphStyle(
            'BodyStyle',
            parent=self.styles['Normal'],
            fontSize=10,
            leading=14,
            spaceBefore=4,
            spaceAfter=4
        )
        
        # Small Style (Footnotes, captions)
        self.small_style = ParagraphStyle(
            'SmallStyle',
            parent=self.styles['Normal'],
            fontSize=8,
            leading=10,
            textColor=reportlab_colors.gray
        )
        
        # Highlight Style (Important information)
        self.highlight_style = ParagraphStyle(
            'HighlightStyle',
            parent=self.styles['Normal'],
            fontSize=10,
            leading=14,
            backColor=reportlab_colors.HexColor('#E8F8F5'),  # Light cyan
            borderPadding=5,
            borderWidth=1,
            borderColor=reportlab_colors.HexColor('#A3E4D7'),  # Lighter cyan
            borderRadius=3
        )
        
        # Positive Style (For positive metrics)
        self.positive_style = ParagraphStyle(
            'PositiveStyle',
            parent=self.body_style,
            textColor=reportlab_colors.HexColor(self.color_positive)
        )
        
        # Negative Style (For negative metrics)
        self.negative_style = ParagraphStyle(
            'NegativeStyle',
            parent=self.body_style,
            textColor=reportlab_colors.HexColor(self.color_negative)
        )
        
        # Table header style
        self.table_header_style = ParagraphStyle(
            'TableHeaderStyle',
            parent=self.body_style,
            fontName='Helvetica-Bold',
            alignment=TA_CENTER,
            textColor=reportlab_colors.whitesmoke,
            backColor=reportlab_colors.HexColor(self.color_primary)
        )
        
        # Table cell style
        self.table_cell_style = ParagraphStyle(
            'TableCellStyle',
            parent=self.body_style
        )
        
        # Quote style
        self.quote_style = ParagraphStyle(
            'QuoteStyle',
            parent=self.body_style,
            fontName='Helvetica-Oblique',
            leftIndent=20,
            rightIndent=20,
            spaceBefore=10,
            spaceAfter=10,
            leading=14,
            borderColor=reportlab_colors.HexColor(self.color_accent),
            borderWidth=1,
            borderPadding=8,
            borderRadius=5
        )
        
    def load_data(self, data_file=None):
        """Load data from file or use the function output file."""
        try:
            # If data is already loaded, just return
            if self.data is not None:
                logger.info(f"Using already loaded data for {self.ticker}")
                return True
                
            if data_file is None:
                data_file = f"function_outputs/analyze_stock_output.txt"
            
            with open(data_file, 'r') as f:
                self.data = json.load(f)
            
            logger.info(f"Successfully loaded data for {self.ticker}")
            return True
        except Exception as e:
            logger.error(f"Error loading data: {str(e)}")
            return False
            
    def set_data(self, data):
        """Directly set the analysis data."""
        self.data = data
        logger.info(f"Analysis data directly set for {self.ticker}")
        return True
    
    def generate_report(self):
        """Generate the full PDF report with robust error handling."""
        if not self.data:
            logger.error("No data loaded. Cannot generate report.")
            return False
        
        try:
            pdf_file = f"{self.output_dir}/{self.ticker}_Analysis_{self.report_date}.pdf"
            
            # Create a custom page template with a header and footer
            def header_footer(canvas, doc):
                canvas.saveState()
                
                # Header
                canvas.setFillColor(reportlab_colors.HexColor(self.color_primary))
                canvas.rect(0.5 * inch, 10.4 * inch, 7.5 * inch, 0.6 * inch, fill=1)
                
                # Header text
                canvas.setFillColor(reportlab_colors.white)
                canvas.setFont('Helvetica-Bold', 14)
                canvas.drawString(inch, 10.7 * inch, f"{self.ticker} Stock Analysis")
                
                # Add date
                canvas.setFont('Helvetica', 10)
                canvas.drawRightString(8 * inch, 10.7 * inch, f"Report Date: {self.report_date}")
                
                # Footer
                canvas.setFillColor(reportlab_colors.HexColor('#F8F9F9'))  # Light gray
                canvas.rect(0.5 * inch, 0.5 * inch, 7.5 * inch, 0.3 * inch, fill=1)
                
                # Footer text
                canvas.setFillColor(reportlab_colors.HexColor(self.color_primary))
                canvas.setFont('Helvetica', 8)
                canvas.drawString(inch, 0.65 * inch, "Stock Analysis Report")
                
                # Add page number
                canvas.drawRightString(8 * inch, 0.65 * inch, f"Page {doc.page}")
                
                canvas.restoreState()
            
            # Create the document with the custom header/footer
            doc = SimpleDocTemplate(
                pdf_file, 
                pagesize=letter,
                leftMargin=0.75*inch,
                rightMargin=0.75*inch,
                topMargin=1.2*inch,
                bottomMargin=1*inch
            )
            
            # List to hold all elements for the PDF
            elements = []
            
            # Function to safely add elements to the document
            def safe_add_elements(new_elements, section_name="unknown"):
                """Safely add elements to the document with error checking."""
                if not isinstance(new_elements, list):
                    new_elements = [new_elements]
                    
                for element in new_elements:
                    try:
                        # Skip any None elements
                        if element is None:
                            continue
                            
                        # Check if it's an Image and verify it has valid data
                        if isinstance(element, Image):
                            # If image data is invalid or width is None, skip it
                            if getattr(element, '_image', None) is None or element.imageWidth is None:
                                logger.warning(f"Skipping invalid image in {section_name} section")
                                continue
                        
                        # Check if it's a Table and verify it has data
                        if isinstance(element, Table):
                            if not hasattr(element, '_rowHeights') or not element._rowHeights:
                                logger.warning(f"Skipping invalid table in {section_name} section")
                                continue
                                                    
                        # Add the validated element
                        elements.append(element)
                    except Exception as e:
                        logger.error(f"Error adding element in {section_name} section: {str(e)}")
                        # Add a replacement paragraph instead
                        elements.append(Paragraph(f"Error displaying {section_name} content: {str(e)}", self.body_style))
            
            # Cover page
            try:
                cover_elements = self._create_cover_page()
                safe_add_elements(cover_elements, "cover page")
                safe_add_elements(PageBreak(), "cover page break")
            except Exception as e:
                logger.error(f"Error creating cover page: {str(e)}")
                elements.append(Paragraph(f"{self.ticker} Stock Analysis Report", self.title_style))
                elements.append(PageBreak())
            
            # Table of contents
            try:
                # Add table of contents title
                safe_add_elements(Paragraph("Table of Contents", self.subtitle_style), "ToC title")
                
                toc_data = [
                    ["1.", "Company Overview", ""],
                    ["2.", "Price History", ""],
                    ["3.", "Technical Analysis", ""],
                    ["4.", "Financial Highlights", ""],
                    ["5.", "Recent News", ""]
                ]
                
                # Add dividend section if available
                if 'dividends' in self.data and self.data['dividends']:
                    toc_data.append(["6.", "Dividend Information", ""])
                
                # Style the table of contents
                toc_table = Table(toc_data, colWidths=[0.4*inch, 4.6*inch, 1*inch])
                toc_table.setStyle(TableStyle([
                    ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.white),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                    ('TOPPADDING', (0, 0), (-1, -1), 10),
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 12),
                    ('TEXTCOLOR', (0, 0), (-1, -1), reportlab_colors.HexColor(self.color_primary)),
                    ('LINEBELOW', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ]))
                
                safe_add_elements(toc_table, "ToC table")
                safe_add_elements(Spacer(1, 0.5*inch), "ToC spacer")
                
                # Add disclaimer
                disclaimer_text = "Disclaimer: This report is for informational purposes only and should not be considered financial advice. Always consult with a financial advisor before making investment decisions. Past performance is not indicative of future results."
                safe_add_elements(Paragraph(f"<i>{disclaimer_text}</i>", self.small_style), "disclaimer")
                safe_add_elements(PageBreak(), "ToC break")
            except Exception as e:
                logger.error(f"Error creating table of contents: {str(e)}")
                safe_add_elements(PageBreak(), "error break")
            
            # Main content sections - each in a try-except block
            
            # 1. Company Overview
            try:
                safe_add_elements(Paragraph("1. Company Overview", self.subtitle_style), "company section title")
                overview_elements = self._create_company_overview()
                safe_add_elements(overview_elements, "company overview")
                safe_add_elements(PageBreak(), "company section break")
            except Exception as e:
                logger.error(f"Error adding company overview: {str(e)}")
                safe_add_elements(Paragraph("Error loading company overview data", self.body_style), "company error")
                safe_add_elements(PageBreak(), "company error break")
            
            # 2. Price History
            try:
                safe_add_elements(Paragraph("2. Price History", self.subtitle_style), "price section title")
                price_elements = self._create_price_chart()
                safe_add_elements(price_elements, "price chart")
                safe_add_elements(PageBreak(), "price section break")
            except Exception as e:
                logger.error(f"Error adding price history: {str(e)}")
                safe_add_elements(Paragraph("Error loading price history data", self.body_style), "price error")
                safe_add_elements(PageBreak(), "price error break")
            
            # 3. Technical Analysis
            try:
                safe_add_elements(Paragraph("3. Technical Analysis", self.subtitle_style), "technical section title")
                tech_elements = self._create_technical_analysis()
                safe_add_elements(tech_elements, "technical analysis")
                safe_add_elements(PageBreak(), "technical section break")
            except Exception as e:
                logger.error(f"Error adding technical analysis: {str(e)}")
                safe_add_elements(Paragraph("Error loading technical analysis data", self.body_style), "technical error")
                safe_add_elements(PageBreak(), "technical error break")
            
            # 4. Financial Highlights
            try:
                safe_add_elements(Paragraph("4. Financial Highlights", self.subtitle_style), "financial section title")
                fin_elements = self._create_financial_highlights()
                safe_add_elements(fin_elements, "financial highlights")
                safe_add_elements(PageBreak(), "financial section break")
            except Exception as e:
                logger.error(f"Error adding financial highlights: {str(e)}")
                safe_add_elements(Paragraph("Error loading financial highlights data", self.body_style), "financial error")
                safe_add_elements(PageBreak(), "financial error break")
            
            # 5. News Summary
            try:
                safe_add_elements(Paragraph("5. Recent News", self.subtitle_style), "news section title")
                news_elements = self._create_news_summary()
                safe_add_elements(news_elements, "news summary")
            except Exception as e:
                logger.error(f"Error adding news summary: {str(e)}")
                safe_add_elements(Paragraph("Error loading news data", self.body_style), "news error")
            
            # 6. Dividend Information (if available)
            try:
                if 'dividends' in self.data and self.data['dividends']:
                    safe_add_elements(PageBreak(), "dividend section break")
                    safe_add_elements(Paragraph("6. Dividend Information", self.subtitle_style), "dividend section title")
                    div_elements = self._create_dividend_analysis()
                    safe_add_elements(div_elements, "dividend analysis")
            except Exception as e:
                logger.error(f"Error adding dividend information: {str(e)}")
                if 'dividends' in self.data and self.data['dividends']:
                    safe_add_elements(Paragraph("Error loading dividend data", self.body_style), "dividend error")
            
            # Add a credit line at the end
            try:
                safe_add_elements(Spacer(1, 0.5*inch), "credit spacer")
                safe_add_elements(Paragraph(f"Report generated by Stock Analyzer on {self.report_date}", self.small_style), "credit line")
            except Exception as e:
                logger.error(f"Error adding credit line: {str(e)}")
            
            # Build the PDF with custom header/footer
            doc.build(elements, onFirstPage=header_footer, onLaterPages=header_footer)
            
            logger.info(f"Report successfully generated: {pdf_file}")
            return pdf_file
            
        except Exception as e:
            logger.error(f"Error generating report: {str(e)}\n{traceback.format_exc()}")
            raise
    def _create_cover_page(self):
        """Create a professional cover page for the report."""
        elements = []
        
        # Add a spacer at the top
        elements.append(Spacer(1, 1*inch))
        
        # Add report title
        elements.append(Paragraph(f"{self.ticker} Stock Analysis Report", self.title_style))
        
        # Add company name if available
        if self.data.get('details') and self.data['details'].get('name'):
            company_name = self.data['details']['name']
            elements.append(Paragraph(company_name, self.subtitle_style))
        
        # Add report date
        elements.append(Paragraph(f"Generated on {self.report_date}", self.styles['Italic']))
        
        # Add a horizontal line
        elements.append(Spacer(1, 0.5*inch))
        elements.append(HorizontalLine(color=reportlab_colors.HexColor(self.color_accent)))
        elements.append(Spacer(1, 0.5*inch))
        
        # Create a summary box
        current_price = None
        price_change = None
        price_change_pct = None
        
        try:
            if self.data.get('recent_aggregates') and len(self.data['recent_aggregates']) > 1:
                aggs = self.data['recent_aggregates']
                current_price = float(aggs[-1]['c'])
                price_change = current_price - float(aggs[0]['c'])
                price_change_pct = (price_change / float(aggs[0]['c'])) * 100
        except (KeyError, ValueError, TypeError, IndexError) as e:
            logger.warning(f"Could not calculate price change: {str(e)}")
        
        # Add a key metrics table
        if current_price is not None:
            elements.append(Paragraph("Key Metrics", self.section_style))
            
            # Format price change with color indication
            price_change_text = "N/A"
            if price_change is not None and price_change_pct is not None:
                if price_change >= 0:
                    price_change_text = f"+${price_change:.2f} (+{price_change_pct:.2f}%)"
                    price_change_color = self.color_positive
                else:
                    price_change_text = f"-${abs(price_change):.2f} ({price_change_pct:.2f}%)"
                    price_change_color = self.color_negative
            
            metrics_data = [
                ["Current Price", "30-Day Change", "Exchange"],
                [
                    f"${current_price:.2f}",
                    price_change_text,
                    self.data.get('details', {}).get('primary_exchange', 'N/A')
                ]
            ]
            
            metrics_table = Table(metrics_data, colWidths=[2*inch, 2*inch, 2*inch])
            metrics_table.setStyle(TableStyle([
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, 1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 12),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                ('TOPPADDING', (0, 0), (-1, -1), 10),
            ]))
            
            elements.append(metrics_table)
            elements.append(Spacer(1, 0.3*inch))
        
        # Add brief company description
        if self.data.get('details') and self.data['details'].get('description'):
            elements.append(Paragraph("Summary", self.section_style))
            
            # Get first sentence of description
            description = self.data['details']['description']
            first_sentence = description.split('.')[0] + '.'
            
            elements.append(Paragraph(first_sentence, self.body_style))
            elements.append(Spacer(1, 0.3*inch))
        
        # Add report purpose
        purpose_text = f"This report provides a comprehensive analysis of {self.ticker} stock, including price history, technical indicators, financial highlights, recent news, and dividend information. Use this report to gain insights into the company's performance and make informed investment decisions."
        elements.append(Paragraph(purpose_text, self.quote_style))
        
        return elements
    
    def _create_company_overview(self):
        """Create the company overview section."""
        elements = []
        
        try:
            # Make sure details is available
            if not self.data.get('details'):
                elements.append(Paragraph("Company details not available", self.body_style))
                return elements
                
            details = self.data['details']
            
            # Company name and description
            company_name = details.get('name', 'Name not available')
            elements.append(Paragraph(f"<b>{company_name}</b> ({self.ticker})", self.body_style))
            elements.append(Spacer(1, 0.1*inch))
            
            if 'description' in details and details['description']:
                description = details['description']
                # Split description into paragraphs for better readability
                paragraphs = []
                remaining = description
                while len(remaining) > 0:
                    # Find a good breaking point around 500 characters
                    if len(remaining) <= 500:
                        paragraphs.append(remaining)
                        break
                    
                    # Try to break at a period
                    break_point = remaining[:500].rfind('. ') + 1
                    if break_point <= 0:
                        # If no period found, break at a space
                        break_point = remaining[:500].rfind(' ')
                        if break_point <= 0:
                            # If no space found, just break at 500
                            break_point = 500
                    
                    paragraphs.append(remaining[:break_point])
                    remaining = remaining[break_point:].strip()
                
                for para in paragraphs:
                    elements.append(Paragraph(para, self.body_style))
                    elements.append(Spacer(1, 0.05*inch))
            
            elements.append(Spacer(1, 0.1*inch))
            
            # Create company info in a nicer format
            elements.append(Paragraph("Company Information", self.section_style))
            
            # First row: Market Cap, Industry, Exchange
            row1_data = [
                ["Market Cap", "Industry", "Exchange"],
                [
                    f"${self._format_number(details.get('market_cap', 'N/A'))}",
                    details.get('sic_description', 'N/A'),
                    details.get('primary_exchange', 'N/A')
                ]
            ]
            
            row1_table = Table(row1_data, colWidths=[2*inch, 2*inch, 2*inch])
            row1_table.setStyle(TableStyle([
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, 1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 7),
                ('TOPPADDING', (0, 0), (-1, -1), 7),
            ]))
            
            elements.append(row1_table)
            elements.append(Spacer(1, 0.1*inch))
            
            # Second row: Type, CIK, Country
            row2_data = [
                ["Company Type", "CIK", "Country"],
                [
                    details.get('type', 'N/A'),
                    details.get('cik', 'N/A'),
                    details.get('locale', 'N/A')
                ]
            ]
            
            row2_table = Table(row2_data, colWidths=[2*inch, 2*inch, 2*inch])
            row2_table.setStyle(TableStyle([
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_secondary)),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, 1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 7),
                ('TOPPADDING', (0, 0), (-1, -1), 7),
            ]))
            
            elements.append(row2_table)
            
            # Add additional company information if available
            if details.get('address') or details.get('phone_number') or details.get('homepage_url'):
                elements.append(Spacer(1, 0.2*inch))
                elements.append(Paragraph("Additional Information", self.section_style))
                
                additional_info = []
                
                if details.get('address'):
                    address = details.get('address', {})
                    address_str = ', '.join(filter(None, [
                        address.get('address1', ''),
                        address.get('city', ''),
                        address.get('state', ''),
                        address.get('postal_code', '')
                    ]))
                    if address_str:
                        additional_info.append(f"<b>Address:</b> {address_str}")
                
                if details.get('phone_number'):
                    additional_info.append(f"<b>Phone:</b> {details['phone_number']}")
                
                if details.get('homepage_url'):
                    additional_info.append(f"<b>Website:</b> {details['homepage_url']}")
                
                if additional_info:
                    for info in additional_info:
                        elements.append(Paragraph(info, self.body_style))
                        elements.append(Spacer(1, 0.05*inch))
            
        except Exception as e:
            logger.error(f"Error creating company overview: {str(e)}")
            elements.append(Paragraph(f"Error processing company data: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _create_price_chart(self):
        """Create the price chart section."""
        elements = []
        
        if not self.data.get('recent_aggregates'):
            elements.append(Paragraph("No price data available", self.body_style))
            return elements
        
        # Prepare data for price chart
        aggs = self.data['recent_aggregates']
        dates = []
        dt_objects = []  # Actual datetime objects for proper plotting
        prices = []
        volumes = []
        
        try:
            for bar in aggs:
                try:
                    # Convert timestamp to datetime
                    dt = datetime.fromtimestamp(bar['t'] / 1000)
                    date_str = dt.strftime('%Y-%m-%d')
                    
                    # Store both string representation and actual datetime object
                    dates.append(date_str)
                    dt_objects.append(dt)
                    
                    # Ensure numerical values
                    prices.append(float(bar['c']))  # Closing price
                    volumes.append(float(bar['v']))  # Volume
                except (KeyError, ValueError, TypeError) as e:
                    logger.warning(f"Error processing bar data: {str(e)}, bar: {bar}")
                    continue
            
            # Make sure we have data to plot
            if not prices or not dt_objects:
                elements.append(Paragraph("Insufficient price data for visualization", self.body_style))
                return elements
            
            # Sort data by date to ensure proper ordering
            combined_data = sorted(zip(dt_objects, prices, volumes))
            dt_objects = [item[0] for item in combined_data]
            prices = [item[1] for item in combined_data]
            volumes = [item[2] for item in combined_data]
            dates = [dt.strftime('%Y-%m-%d') for dt in dt_objects]
            
            # Create enhanced price chart
            fig = plt.figure(figsize=(10, 7))
            gs = GridSpec(2, 1, height_ratios=[3, 1])
            
            # Price subplot with improved styling
            ax1 = fig.add_subplot(gs[0])
            
            # Plot price with gradient fill
            line, = ax1.plot(dt_objects, prices, linewidth=2.5, color=self.color_primary)
            
            # Add fill between the line and bottom
            ax1.fill_between(dt_objects, prices, min(prices)-1, alpha=0.2, color=self.color_accent)
            
            # Add a title with better formatting
            title = ax1.set_title(f"{self.ticker} - Price History (Last 30 Days)", 
                                fontsize=16, fontweight='bold', color=self.color_primary)
            title.set_path_effects([path_effects.withStroke(linewidth=0.5, foreground='gray')])
            
            ax1.set_ylabel("Price ($)", fontsize=12, fontweight='bold', color=self.color_primary)
            ax1.grid(True, alpha=0.3, linestyle='--')
            ax1.spines['top'].set_visible(False)
            ax1.spines['right'].set_visible(False)
            
            # Hide x-axis labels for the top plot
            plt.setp(ax1.get_xticklabels(), visible=False)
            
            # Format y-axis as currency with commas
            ax1.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'${x:,.2f}'))
            
            # Add SMA if available
            if 'sma_50' in self.data and self.data['sma_50'].get('values'):
                sma_data = self.data['sma_50']['values']
                sma_dt_objects = []
                sma_values = []
                
                for point in sma_data:
                    try:
                        sma_dt = datetime.fromtimestamp(point['timestamp'] / 1000)
                        # Only include points within our date range
                        if min(dt_objects) <= sma_dt <= max(dt_objects):
                            sma_dt_objects.append(sma_dt)
                            sma_values.append(float(point['value']))
                    except (KeyError, ValueError, TypeError) as e:
                        logger.warning(f"Error processing SMA data: {str(e)}")
                        continue
                
                if sma_dt_objects and sma_values:
                    # Sort SMA data by date
                    sma_combined = sorted(zip(sma_dt_objects, sma_values))
                    sma_dt_objects = [item[0] for item in sma_combined]
                    sma_values = [item[1] for item in sma_combined]
                    
                    ax1.plot(sma_dt_objects, sma_values, '--', linewidth=1.8, 
                            color=self.color_secondary, label='50-day SMA')
                    ax1.legend(loc='upper left', frameon=True, facecolor='white', 
                                edgecolor='lightgray', framealpha=0.9)
            
            # Add min and max prices with improved annotations
            if prices:
                min_price = min(prices)
                max_price = max(prices)
                min_idx = prices.index(min_price)
                max_idx = prices.index(max_price)
                
                # Min price annotation
                min_text = ax1.annotate(f"${min_price:.2f}", 
                            xy=(dt_objects[min_idx], min_price),
                            xytext=(0, -30),
                            textcoords="offset points",
                            ha='center',
                            va='top',
                            fontsize=10,
                            fontweight='bold',
                            color='white',
                            bbox=dict(boxstyle="round,pad=0.3", 
                                    fc=self.color_negative, 
                                    ec=self.color_negative,
                                    alpha=0.8),
                            arrowprops=dict(arrowstyle="->", 
                                            color=self.color_negative,
                                            lw=1.5))
                
                # Max price annotation
                max_text = ax1.annotate(f"${max_price:.2f}", 
                            xy=(dt_objects[max_idx], max_price),
                            xytext=(0, 30),
                            textcoords="offset points",
                            ha='center',
                            va='bottom',
                            fontsize=10,
                            fontweight='bold',
                            color='white',
                            bbox=dict(boxstyle="round,pad=0.3", 
                                    fc=self.color_positive, 
                                    ec=self.color_positive,
                                    alpha=0.8),
                            arrowprops=dict(arrowstyle="->", 
                                            color=self.color_positive,
                                            lw=1.5))
            
            # Volume subplot with enhanced styling
            ax2 = fig.add_subplot(gs[1], sharex=ax1)
            
            # Create color map for volume bars based on price movement
            bar_colors = []
            for i in range(1, len(prices)):
                if prices[i] >= prices[i-1]:
                    bar_colors.append(self.color_positive)  # Up day
                else:
                    bar_colors.append(self.color_negative)  # Down day
            
            # Add neutral color for first day
            if bar_colors:
                bar_colors.insert(0, self.color_neutral)
                
                # Make sure colors match the data points
                if len(bar_colors) > len(dt_objects):
                    bar_colors = bar_colors[:len(dt_objects)]
                elif len(bar_colors) < len(dt_objects):
                    bar_colors.extend([self.color_neutral] * (len(dt_objects) - len(bar_colors)))
            
            # Add volume bars with nicer styling
            ax2.bar(dt_objects, volumes, color=bar_colors, alpha=0.7, width=0.8)
            ax2.set_ylabel("Volume", fontsize=12, fontweight='bold', color=self.color_primary)
            ax2.set_xlabel("Date", fontsize=12, fontweight='bold', color=self.color_primary)
            ax2.grid(True, alpha=0.3, linestyle='--')
            ax2.spines['top'].set_visible(False)
            ax2.spines['right'].set_visible(False)
            
            # Format volume with K/M suffixes
            ax2.yaxis.set_major_formatter(
                FuncFormatter(lambda x, _: f'{x/1e6:.1f}M' if x >= 1e6 else f'{x/1e3:.0f}K' if x >= 1e3 else f'{x:.0f}'))
            
            # Format x-axis with cleaner date labels
            date_fmt = mdates.DateFormatter('%b %d')
            ax2.xaxis.set_major_formatter(date_fmt)
            
            # Use a custom locator to avoid crowded labels
            locator = mdates.AutoDateLocator(minticks=4, maxticks=8)
            ax2.xaxis.set_major_locator(locator)
            
            plt.xticks(rotation=30, ha='right')
            
            # Improve overall layout
            plt.tight_layout()
            fig.subplots_adjust(hspace=0.05)  # Reduce space between plots
            
            # Add a light grid background for better readability
            ax1.set_facecolor('#F8F9F9')
            ax2.set_facecolor('#F8F9F9')
            
            # Save to BytesIO with higher resolution
            img_data = BytesIO()
            plt.savefig(img_data, format='png', dpi=150, bbox_inches='tight')
            img_data.seek(0)
            plt.close()
            
            # Add image to PDF
            image = Image(img_data, width=7*inch, height=5*inch)
            elements.append(image)
            
            # Add price statistics in a more attractive table
            current_price = prices[-1] if prices else 'N/A'
            
            # Calculate price change with error handling
            try:
                price_change = prices[-1] - prices[0] if prices and len(prices) > 1 else 'N/A'
                price_change_pct = (price_change / prices[0] * 100) if prices and prices[0] != 0 else 'N/A'
            except (TypeError, IndexError):
                price_change = 'N/A'
                price_change_pct = 'N/A'
            
            elements.append(Spacer(1, 0.2*inch))
            elements.append(Paragraph("Price Statistics", self.section_style))
            
            # Format price change text with color indication
            price_change_text = "N/A"
            if isinstance(price_change, (int, float)) and isinstance(price_change_pct, (int, float)):
                if price_change >= 0:
                    price_change_text = f"+${price_change:.2f} (+{price_change_pct:.2f}%)"
                    price_change_color = self.color_positive
                else:
                    price_change_text = f"-${abs(price_change):.2f} ({price_change_pct:.2f}%)"
                    price_change_color = self.color_negative
            
            # Format price statistics for the table
            stats_data = [
                ["Metric", "Value"],
                ["Current Price", f"${current_price:.2f}" if isinstance(current_price, (int, float)) else 'N/A'],
                ["30-Day Change", price_change_text],
                ["Highest Price (30d)", f"${max_price:.2f}" if isinstance(max_price, (int, float)) else 'N/A'],
                ["Lowest Price (30d)", f"${min_price:.2f}" if isinstance(min_price, (int, float)) else 'N/A']
            ]
            
            # Add average volume with error handling
            try:
                avg_volume = sum(volumes) / len(volumes) if volumes else 'N/A'
                stats_data.append(["Average Volume", f"{avg_volume:,.0f}" if isinstance(avg_volume, (int, float)) else 'N/A'])
            except (TypeError, ZeroDivisionError):
                stats_data.append(["Average Volume", "N/A"])
            
            # Create a more attractive table
            stats_table = Table(stats_data, colWidths=[3*inch, 3*inch])
            stats_table.setStyle(TableStyle([
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
            ]))
            
            # Color the price change row based on positive/negative
            if isinstance(price_change, (int, float)):
                color = reportlab_colors.HexColor(self.color_positive) if price_change >= 0 else reportlab_colors.HexColor(self.color_negative)
                stats_table.setStyle(TableStyle([
                    ('TEXTCOLOR', (1, 2), (1, 2), color),
                    ('FONTNAME', (1, 2), (1, 2), 'Helvetica-Bold'),
                ]))
            
            elements.append(stats_table)
            
            # Add price trend commentary
            elements.append(Spacer(1, 0.2*inch))
            elements.append(Paragraph("Price Trend Commentary", self.section_style))
            
            # Generate commentary based on the price data
            commentary = self._generate_price_commentary(prices, dt_objects)
            
            elements.append(Paragraph(commentary, self.body_style))
            
        except Exception as e:
            logger.error(f"Error creating price chart: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph(f"Error generating price chart: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _generate_price_commentary(self, prices, dates):
        """Generate commentary about price trends."""
        try:
            if not prices or len(prices) < 5:
                return "Insufficient data to analyze price trends."
            
            current_price = prices[-1]
            start_price = prices[0]
            price_change = current_price - start_price
            price_change_pct = (price_change / start_price) * 100
            
            # Determine overall trend
            if price_change_pct > 10:
                trend = "strong upward"
            elif price_change_pct > 5:
                trend = "moderate upward"
            elif price_change_pct > 1:
                trend = "slight upward"
            elif price_change_pct > -1:
                trend = "relatively flat"
            elif price_change_pct > -5:
                trend = "slight downward"
            elif price_change_pct > -10:
                trend = "moderate downward"
            else:
                trend = "strong downward"
            
            # Analyze volatility
            price_diffs = [abs(prices[i] - prices[i-1]) / prices[i-1] * 100 for i in range(1, len(prices))]
            avg_daily_change = sum(price_diffs) / len(price_diffs)
            
            if avg_daily_change > 2.5:
                volatility = "highly volatile"
            elif avg_daily_change > 1.5:
                volatility = "moderately volatile"
            elif avg_daily_change > 0.8:
                volatility = "showing typical market volatility"
            else:
                volatility = "relatively stable"
            
            # Identify recent momentum (last 5 days)
            recent_prices = prices[-5:] if len(prices) >= 5 else prices
            recent_change = recent_prices[-1] - recent_prices[0]
            recent_change_pct = (recent_change / recent_prices[0]) * 100
            
            if recent_change_pct > 3:
                momentum = "strong positive momentum"
            elif recent_change_pct > 1:
                momentum = "positive momentum"
            elif recent_change_pct > -1:
                momentum = "neutral momentum"
            elif recent_change_pct > -3:
                momentum = "negative momentum"
            else:
                momentum = "strong negative momentum"
            
            # Generate commentary
            date_range = f"{dates[0].strftime('%B %d, %Y')} to {dates[-1].strftime('%B %d, %Y')}"
            
            commentary = f"Over the period from {date_range}, {self.ticker} has shown a {trend} trend, with the stock price "
            
            if price_change >= 0:
                commentary += f"increasing by ${price_change:.2f} ({price_change_pct:.2f}%). "
            else:
                commentary += f"decreasing by ${abs(price_change):.2f} ({price_change_pct:.2f}%). "
            
            commentary += f"The stock has been {volatility} during this period, with an average daily price movement of {avg_daily_change:.2f}%. "
            
            commentary += f"Recently, the stock has shown {momentum}, indicating potential continuation of the current trend."
            
            # Add trading volume insight if available
            if hasattr(self, 'volumes') and len(self.volumes) > 5:
                recent_volumes = self.volumes[-5:]
                avg_recent_volume = sum(recent_volumes) / len(recent_volumes)
                avg_overall_volume = sum(self.volumes) / len(self.volumes)
                
                if avg_recent_volume > avg_overall_volume * 1.2:
                    commentary += " Trading volume has been higher than average recently, which could indicate increased investor interest or significant news affecting the stock."
                elif avg_recent_volume < avg_overall_volume * 0.8:
                    commentary += " Trading volume has been lower than average recently, which might indicate reduced investor interest or a period of consolidation."
            
            return commentary
            
        except Exception as e:
            logger.error(f"Error generating price commentary: {str(e)}")
            return "Unable to generate price trend commentary due to an error in data analysis."
    
    def _create_technical_analysis(self):
        """Create the technical analysis section."""
        elements = []
        
        try:
            # Check if we have the necessary data
            if not self.data.get('recent_aggregates'):
                elements.append(Paragraph("Insufficient price data for technical analysis", self.body_style))
                return elements
            
            # Get the latest price and SMA values
            aggs = self.data['recent_aggregates']
            
            if not aggs:
                elements.append(Paragraph("No price aggregates available", self.body_style))
                return elements
                
            try:
                latest_price = float(aggs[-1]['c'])
            except (KeyError, ValueError, TypeError, IndexError):
                latest_price = None
                logger.warning("Could not extract latest price from aggregates")
            
            # Get SMA data if available
            latest_sma = None
            if self.data.get('sma_50') and self.data['sma_50'].get('values'):
                sma_values = self.data['sma_50']['values']
                if sma_values:
                    try:
                        latest_sma = float(sma_values[-1]['value'])
                    except (KeyError, ValueError, TypeError, IndexError):
                        latest_sma = None
                        logger.warning("Could not extract latest SMA value")
            
            # Calculate RSI (14-day)
            latest_rsi = None
            
            if len(aggs) >= 14:
                try:
                    prices = []
                    for bar in aggs:
                        if 'c' in bar and bar['c'] is not None:
                            try:
                                prices.append(float(bar['c']))
                            except (ValueError, TypeError):
                                logger.warning(f"Could not convert price value to float: {bar['c']}")
                                
                    if len(prices) >= 14:
                        rsi = self._calculate_rsi(prices, 14)
                        latest_rsi = rsi[-1] if rsi else None
                    else:
                        logger.warning(f"Insufficient valid price points for RSI calculation, needed 14, got {len(prices)}")
                except Exception as e:
                    logger.error(f"Error calculating RSI: {str(e)}")
            else:
                logger.info(f"Insufficient data points for RSI calculation, needed 14, got {len(aggs)}")
            
            # Calculate MACD if we have enough data points
            macd_line = None
            signal_line = None
            macd_hist = None
            
            if len(aggs) >= 26:
                try:
                    prices = [float(bar['c']) for bar in aggs if 'c' in bar and bar['c'] is not None]
                    if len(prices) >= 26:
                        # Calculate EMA-12
                        ema12 = self._calculate_ema(prices, 12)
                        
                        # Calculate EMA-26
                        ema26 = self._calculate_ema(prices, 26)
                        
                        # Calculate MACD line
                        macd_line = ema12[-1] - ema26[-1]
                        
                        # Calculate signal line (9-day EMA of MACD line)
                        if len(ema12) >= 9 and len(ema26) >= 9:
                            macd_values = [ema12[i] - ema26[i] for i in range(len(ema26))]
                            signal_line = self._calculate_ema(macd_values, 9)[-1]
                            
                            # Calculate histogram
                            macd_hist = macd_line - signal_line
                except Exception as e:
                    logger.error(f"Error calculating MACD: {str(e)}")
            
            # Create a more professional technical indicators section
            elements.append(Paragraph("Technical Indicators", self.section_style))
            
            # Generate a professional-looking indicators table
            indicators_data = [
                ["Indicator", "Value", "Signal"]
            ]
            
            # Add SMA indicator
            if latest_price is not None and latest_sma is not None:
                sma_signal = "BULLISH" if latest_price > latest_sma else "BEARISH"
                sma_color = self.color_positive if latest_price > latest_sma else self.color_negative
                
                indicators_data.append([
                    "50-day SMA", 
                    f"${latest_sma:.2f}",
                    sma_signal
                ])
            else:
                indicators_data.append([
                    "50-day SMA",
                    "N/A",
                    "N/A"
                ])
            
            # Add RSI indicator
            if latest_rsi is not None:
                if latest_rsi < 30:
                    rsi_signal = "OVERSOLD (BULLISH)"
                    rsi_color = self.color_positive
                elif latest_rsi > 70:
                    rsi_signal = "OVERBOUGHT (BEARISH)"
                    rsi_color = self.color_negative
                else:
                    rsi_signal = "NEUTRAL"
                    rsi_color = self.color_neutral
                
                indicators_data.append([
                    "RSI (14-day)",
                    f"{latest_rsi:.2f}",
                    rsi_signal
                ])
            else:
                indicators_data.append([
                    "RSI (14-day)",
                    "N/A",
                    "N/A"
                ])
            
            # Add MACD indicator
            if macd_line is not None and signal_line is not None:
                if macd_line > signal_line:
                    macd_signal = "BULLISH"
                    macd_color = self.color_positive
                else:
                    macd_signal = "BEARISH"
                    macd_color = self.color_negative
                
                indicators_data.append([
                    "MACD",
                    f"{macd_line:.4f}",
                    macd_signal
                ])
            else:
                indicators_data.append([
                    "MACD",
                    "N/A",
                    "N/A"
                ])
            
            # Create an enhanced table with better styling
            indicators_table = Table(indicators_data, colWidths=[2.3*inch, 2.3*inch, 1.4*inch])
            
            # Define improved table styling
            table_style = [
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
                ('ALIGN', (2, 0), (2, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
            ]
            
            # Add color-coded signal values
            if latest_price is not None and latest_sma is not None:
                sma_color_hex = reportlab_colors.HexColor(sma_color)
                table_style.append(('TEXTCOLOR', (2, 1), (2, 1), sma_color_hex))
                table_style.append(('FONTNAME', (2, 1), (2, 1), 'Helvetica-Bold'))
            
            if latest_rsi is not None:
                rsi_color_hex = reportlab_colors.HexColor(rsi_color)
                table_style.append(('TEXTCOLOR', (2, 2), (2, 2), rsi_color_hex))
                table_style.append(('FONTNAME', (2, 2), (2, 2), 'Helvetica-Bold'))
            
            if macd_line is not None and signal_line is not None:
                macd_color_hex = reportlab_colors.HexColor(macd_color)
                table_style.append(('TEXTCOLOR', (2, 3), (2, 3), macd_color_hex))
                table_style.append(('FONTNAME', (2, 3), (2, 3), 'Helvetica-Bold'))
            
            # Apply the table style
            indicators_table.setStyle(TableStyle(table_style))
            
            elements.append(indicators_table)
            elements.append(Spacer(1, 0.2*inch))
            
            # Add technical analysis commentary
            elements.append(Paragraph("Technical Analysis Commentary", self.section_style))
            
            # Generate extended technical commentary
            commentary = self._generate_technical_commentary(
                latest_price, latest_sma, latest_rsi, macd_line, signal_line, macd_hist
            )
            
            elements.append(Paragraph(commentary, self.body_style))
            
            # Add a trend summary box
            trend_direction = self._determine_trend_direction(latest_price, latest_sma, latest_rsi, macd_line, signal_line)
            trend_strength = self._determine_trend_strength(latest_price, latest_sma, latest_rsi, macd_line, signal_line)
            
            elements.append(Spacer(1, 0.2*inch))
            elements.append(Paragraph("Technical Trend Summary", self.section_style))
            
            trend_data = [
                ["Overall Trend", "Trend Strength", "Recommended Action"],
                [trend_direction, trend_strength, self._get_recommended_action(trend_direction, trend_strength)]
            ]
            
            trend_table = Table(trend_data, colWidths=[2*inch, 2*inch, 2*inch])
            
            # Define the trend table style
            trend_style = [
                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_secondary)),
                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
            ]
            
            # Color code the trend direction
            if trend_direction == "BULLISH":
                trend_style.append(('TEXTCOLOR', (0, 1), (0, 1), reportlab_colors.HexColor(self.color_positive)))
                trend_style.append(('FONTNAME', (0, 1), (0, 1), 'Helvetica-Bold'))
            elif trend_direction == "BEARISH":
                trend_style.append(('TEXTCOLOR', (0, 1), (0, 1), reportlab_colors.HexColor(self.color_negative)))
                trend_style.append(('FONTNAME', (0, 1), (0, 1), 'Helvetica-Bold'))
            else:
                trend_style.append(('TEXTCOLOR', (0, 1), (0, 1), reportlab_colors.HexColor(self.color_neutral)))
            
            # Apply the trend table style
            trend_table.setStyle(TableStyle(trend_style))
            
            elements.append(trend_table)
            
        except Exception as e:
            logger.error(f"Error creating technical analysis: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph(f"Error processing technical analysis data: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _determine_trend_direction(self, price, sma, rsi, macd_line, signal_line):
        """Determine the overall trend direction based on technical indicators."""
        bullish_signals = 0
        bearish_signals = 0
        total_signals = 0
        
        # Price vs SMA
        if price is not None and sma is not None:
            total_signals += 1
            if price > sma:
                bullish_signals += 1
            else:
                bearish_signals += 1
        
        # RSI
        if rsi is not None:
            total_signals += 1
            if rsi < 30:
                bullish_signals += 1
            elif rsi > 70:
                bearish_signals += 1
            elif rsi > 50:
                bullish_signals += 0.5
            else:
                bearish_signals += 0.5
        
        # MACD
        if macd_line is not None and signal_line is not None:
            total_signals += 1
            if macd_line > signal_line:
                bullish_signals += 1
            else:
                bearish_signals += 1
        
        # Determine overall trend
        if total_signals == 0:
            return "NEUTRAL"
        
        bullish_percentage = bullish_signals / total_signals
        
        if bullish_percentage >= 0.7:
            return "BULLISH"
        elif bullish_percentage <= 0.3:
            return "BEARISH"
        else:
            return "NEUTRAL"
    
    def _determine_trend_strength(self, price, sma, rsi, macd_line, signal_line):
        """Determine the strength of the trend based on technical indicators."""
        strength_signals = 0
        total_signals = 0
        
        # Price vs SMA
        if price is not None and sma is not None:
            total_signals += 1
            # Strong divergence from SMA indicates stronger trend
            pct_diff = abs(price - sma) / sma * 100
            if pct_diff > 10:
                strength_signals += 1
            elif pct_diff > 5:
                strength_signals += 0.7
            elif pct_diff > 2:
                strength_signals += 0.4
            else:
                strength_signals += 0.2
        
        # RSI extremes
        if rsi is not None:
            total_signals += 1
            if rsi < 20 or rsi > 80:
                strength_signals += 1
            elif rsi < 30 or rsi > 70:
                strength_signals += 0.7
            elif rsi < 40 or rsi > 60:
                strength_signals += 0.4
            else:
                strength_signals += 0.2
        
        # MACD divergence
        if macd_line is not None and signal_line is not None:
            total_signals += 1
            # Strong divergence indicates stronger trend
            divergence = abs(macd_line - signal_line)
            if divergence > 0.5:  # Adjust threshold based on typical values
                strength_signals += 1
            elif divergence > 0.2:
                strength_signals += 0.7
            elif divergence > 0.1:
                strength_signals += 0.4
            else:
                strength_signals += 0.2
        
        # Determine overall strength
        if total_signals == 0:
            return "UNKNOWN"
        
        strength_percentage = strength_signals / total_signals
        
        if strength_percentage >= 0.8:
            return "STRONG"
        elif strength_percentage >= 0.5:
            return "MODERATE"
        else:
            return "WEAK"
    
    def _get_recommended_action(self, trend, strength):
        """Get a recommended action based on trend direction and strength."""
        if trend == "BULLISH":
            if strength == "STRONG":
                return "CONSIDER BUY"
            elif strength == "MODERATE":
                return "CAUTIOUS BUY"
            else:
                return "HOLD/MONITOR"
        elif trend == "BEARISH":
            if strength == "STRONG":
                return "CONSIDER SELL"
            elif strength == "MODERATE":
                return "CAUTIOUS SELL"
            else:
                return "HOLD/MONITOR"
        else:
            return "HOLD/MONITOR"
    
    def _calculate_rsi(self, prices, window=14):
        """Calculate Relative Strength Index."""
        try:
            # Ensure we have numeric data
            prices = [float(price) for price in prices]
            
            if len(prices) < window + 1:
                logger.warning(f"Insufficient data points to calculate RSI (needed {window+1}, got {len(prices)})")
                return None
            
            # Calculate price changes
            delta = np.diff(prices)
            
            # Create arrays for gains and losses
            gains = np.zeros_like(delta)
            losses = np.zeros_like(delta)
            
            # Separate gains and losses
            gains[delta > 0] = delta[delta > 0]
            losses[delta < 0] = -delta[delta < 0]  # Convert to positive values
            
            # Calculate average gains and losses
            avg_gain = np.mean(gains[:window])
            avg_loss = np.mean(losses[:window])
            
            # Initialize RSI list
            rsi = []
            
            # Calculate first RSI value
            if avg_loss == 0:
                rsi.append(100)
            else:
                rs = avg_gain / avg_loss
                rsi.append(100 - (100 / (1 + rs)))
            
            # Calculate smoothed RSI for remaining points
            for i in range(window, len(delta)):
                avg_gain = (avg_gain * (window - 1) + gains[i]) / window
                avg_loss = (avg_loss * (window - 1) + losses[i]) / window
                
                if avg_loss == 0:
                    rsi.append(100)
                else:
                    rs = avg_gain / avg_loss
                    rsi.append(100 - (100 / (1 + rs)))
            
            return rsi
        except Exception as e:
            logger.error(f"Error calculating RSI: {str(e)}")
            return None
    
    def _calculate_ema(self, prices, span):
        """Calculate Exponential Moving Average."""
        try:
            prices = np.array(prices)
            alpha = 2 / (span + 1)
            
            # Calculate initial SMA
            sma = np.mean(prices[:span])
            
            # Initialize EMA with SMA
            ema = np.zeros_like(prices)
            ema[span-1] = sma
            
            # Calculate EMA for remaining points
            for i in range(span, len(prices)):
                ema[i] = (prices[i] * alpha) + (ema[i-1] * (1 - alpha))
            
            # Return only valid EMA values (from span-1 onwards)
            return ema[span-1:]
        except Exception as e:
            logger.error(f"Error calculating EMA: {str(e)}")
            return None
    
    def _interpret_rsi(self, rsi):
        """Interpret RSI value and return a signal."""
        if rsi is None:
            return "N/A"
            
        if rsi < 30:
            return "Oversold (Bullish)"
        elif rsi > 70:
            return "Overbought (Bearish)"
        else:
            return "Neutral"
    
    def _generate_technical_commentary(self, price, sma, rsi, macd_line, signal_line, macd_hist):
        """Generate comprehensive technical analysis commentary based on indicators."""
        commentary_parts = []
        
        # Price vs SMA analysis
        if price and sma:
            diff_pct = (price - sma) / sma * 100
            if price > sma:
                if diff_pct > 10:
                    commentary_parts.append(f"The stock is trading significantly above its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% higher. This indicates a strong bullish trend, though the stock may be approaching overbought territory.")
                elif diff_pct > 5:
                    commentary_parts.append(f"The stock is trading moderately above its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% higher. This suggests a healthy bullish trend that may continue in the near term.")
                else:
                    commentary_parts.append(f"The stock is trading slightly above its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% higher. This indicates a mild bullish trend, though momentum should be monitored.")
            else:
                diff_pct = abs(diff_pct)
                if diff_pct > 10:
                    commentary_parts.append(f"The stock is trading significantly below its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% lower. This indicates a strong bearish trend, though the stock may be approaching oversold territory.")
                elif diff_pct > 5:
                    commentary_parts.append(f"The stock is trading moderately below its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% lower. This suggests a bearish trend that may continue in the near term.")
                else:
                    commentary_parts.append(f"The stock is trading slightly below its 50-day SMA (${sma:.2f}), with the current price (${price:.2f}) being {diff_pct:.2f}% lower. This indicates a mild bearish trend, though a reversal could occur with positive catalysts.")
        
        # RSI analysis
        if rsi:
            if rsi < 30:
                if rsi < 20:
                    commentary_parts.append(f"The RSI reading of {rsi:.2f} indicates the stock is extremely oversold. This often precedes a strong price reversal to the upside, presenting a potential buying opportunity for contrarian investors.")
                else:
                    commentary_parts.append(f"The RSI reading of {rsi:.2f} indicates the stock is oversold. This may present a buying opportunity, as oversold conditions often precede price reversals to the upside.")
            elif rsi > 70:
                if rsi > 80:
                    commentary_parts.append(f"The RSI reading of {rsi:.2f} indicates the stock is extremely overbought. This often precedes a price correction, suggesting caution for new buyers and potential profit-taking for current holders.")
                else:
                    commentary_parts.append(f"The RSI reading of {rsi:.2f} indicates the stock is overbought. This suggests caution for new buyers, as overbought conditions often precede price reversals to the downside.")
            elif rsi > 60:
                commentary_parts.append(f"The RSI reading of {rsi:.2f} is in the upper neutral range, leaning bullish. While not overbought, the momentum is positive, supporting the current price trend.")
            elif rsi < 40:
                commentary_parts.append(f"The RSI reading of {rsi:.2f} is in the lower neutral range, leaning bearish. While not oversold, the momentum is negative, which may put pressure on prices.")
            else:
                commentary_parts.append(f"The RSI reading of {rsi:.2f} is in the neutral range, suggesting balanced buying and selling pressure. The indicator provides no strong directional signal at this time.")
        
        # MACD analysis
        if macd_line is not None and signal_line is not None:
            if macd_line > signal_line:
                if macd_hist and macd_hist > 0.1:
                    commentary_parts.append(f"The MACD line is above the signal line with a strong positive histogram ({macd_hist:.4f}), indicating robust bullish momentum. This suggests the current upward trend may continue.")
                else:
                    commentary_parts.append(f"The MACD line is above the signal line, generating a bullish signal. This indicates positive momentum, though the strength of the signal should be monitored.")
                
                if macd_line < 0:
                    commentary_parts.append("However, both MACD and signal lines remain below zero, suggesting the overall trend is still bearish despite the recent positive momentum shift.")
            else:
                if macd_hist and macd_hist < -0.1:
                    commentary_parts.append(f"The MACD line is below the signal line with a strong negative histogram ({macd_hist:.4f}), indicating robust bearish momentum. This suggests the current downward trend may continue.")
                else:
                    commentary_parts.append(f"The MACD line is below the signal line, generating a bearish signal. This indicates negative momentum, though the strength of the signal should be monitored.")
                
                if macd_line > 0:
                    commentary_parts.append("However, both MACD and signal lines remain above zero, suggesting the overall trend is still bullish despite the recent negative momentum shift.")
        
        # Combine the commentary
        if not commentary_parts:
            return "Insufficient technical indicator data available to provide comprehensive analysis. Consider using additional sources of information for trading decisions."
        
        # Add a concluding paragraph
        if len(commentary_parts) >= 2:
            all_indicators = []
            
            if price and sma:
                if price > sma:
                    all_indicators.append("bullish (price > SMA)")
                else:
                    all_indicators.append("bearish (price < SMA)")
            
            if rsi:
                if rsi < 30:
                    all_indicators.append("bullish (RSI oversold)")
                elif rsi > 70:
                    all_indicators.append("bearish (RSI overbought)")
                elif rsi > 50:
                    all_indicators.append("slightly bullish (RSI > 50)")
                else:
                    all_indicators.append("slightly bearish (RSI < 50)")
            
            if macd_line is not None and signal_line is not None:
                if macd_line > signal_line:
                    all_indicators.append("bullish (MACD > Signal)")
                else:
                    all_indicators.append("bearish (MACD < Signal)")
            
            # Count bullish vs bearish indicators
            bullish_count = sum(1 for ind in all_indicators if 'bullish' in ind)
            bearish_count = sum(1 for ind in all_indicators if 'bearish' in ind)
            
            # Generate conclusion
            conclusion = "In conclusion, "
            if bullish_count > bearish_count:
                conclusion += f"technical indicators are leaning bullish ({bullish_count} bullish vs {bearish_count} bearish signals). This suggests upward price movements may be more likely in the near term, though investors should monitor for any shift in momentum."
            elif bearish_count > bullish_count:
                conclusion += f"technical indicators are leaning bearish ({bearish_count} bearish vs {bullish_count} bullish signals). This suggests downward price movements may be more likely in the near term, though investors should watch for potential reversals."
            else:
                conclusion += "technical indicators are mixed, showing no clear directional bias. In such cases, it's advisable to wait for more definitive signals before making significant trading decisions."
            
            commentary_parts.append(conclusion)
        
        return " ".join(commentary_parts)
    
    def _create_financial_highlights(self):
        """Create the financial highlights section."""
        elements = []
        
        try:
            # Check if financial data is available
            if not self.data.get('financials'):
                elements.append(Paragraph("No financial data available", self.body_style))
                return elements
            
            financials = self.data['financials']
            
            # Prepare financial metrics table
            if financials:
                # Get the latest financial report
                latest_report = financials[0] if financials else None
                
                if latest_report:
                    report_date = latest_report.get('filing_date', 'N/A')
                    
                    elements.append(Paragraph(f"Latest Financial Data (as of {report_date})", self.section_style))
                    
                    # Extract key financial metrics
                    fin_data = [
                        ["Metric", "Value", "YoY Change"]
                    ]
                    
                    # Try to extract common financial metrics
                    fin_metrics = [
                        ("Revenue", self._extract_financial_metric(latest_report, "revenues")),
                        ("Net Income", self._extract_financial_metric(latest_report, "net_income")),
                        ("EPS", self._extract_financial_metric(latest_report, "eps_basic")),
                        ("Total Assets", self._extract_financial_metric(latest_report, "assets")),
                        ("Total Liabilities", self._extract_financial_metric(latest_report, "liabilities")),
                        ("Cash & Equivalents", self._extract_financial_metric(latest_report, "cash_and_equivalents")),
                    ]
                    
                    # Add year-over-year changes if we have enough historical data
                    if len(financials) > 4:  # Assuming quarterly reports, need at least 5 for YoY comparison
                        yoy_report = None
                        for report in financials:
                            # Find report from approximately 1 year ago
                            report_date = report.get('filing_date')
                            latest_date = latest_report.get('filing_date')
                            
                            if report_date and latest_date:
                                try:
                                    report_dt = datetime.strptime(report_date, '%Y-%m-%d')
                                    latest_dt = datetime.strptime(latest_date, '%Y-%m-%d')
                                    days_diff = (latest_dt - report_dt).days
                                    
                                    if 350 <= days_diff <= 380:  # Approximately 1 year
                                        yoy_report = report
                                        break
                                except ValueError:
                                    pass
                        
                        # Add all available metrics with YoY changes
                        for metric, value in fin_metrics:
                            yoy_value = "N/A"
                            yoy_change = "N/A"
                            
                            if yoy_report:
                                # Extract YoY comparison for this metric
                                metric_key = metric.lower().replace(' ', '_').replace('&', 'and')
                                yoy_value = self._extract_financial_metric(yoy_report, metric_key)
                                
                                # Calculate YoY change if possible
                                if value != "N/A" and yoy_value != "N/A":
                                    # Extract numeric values
                                    try:
                                        current_val = self._parse_financial_value(value)
                                        past_val = self._parse_financial_value(yoy_value)
                                        
                                        if past_val != 0:
                                            pct_change = (current_val - past_val) / past_val * 100
                                            sign = "+" if pct_change >= 0 else ""
                                            yoy_change = f"{sign}{pct_change:.2f}%"
                                    except:
                                        yoy_change = "N/A"
                            
                            fin_data.append([metric, value, yoy_change])
                    else:
                        # Add metrics without YoY changes
                        for metric, value in fin_metrics:
                            if value != "N/A":
                                fin_data.append([metric, value, "N/A"])
                    
                    # Create the table with improved styling
                    if len(fin_data) > 1:  # If we have data beyond headers
                        fin_table = Table(fin_data, colWidths=[2.5*inch, 2*inch, 1.5*inch])
                        
                        # Define improved table styling
                        fin_style = [
                            ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                            ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                            ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                            ('ALIGN', (1, 0), (2, -1), 'RIGHT'),
                            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                            ('FONTSIZE', (0, 0), (-1, 0), 12),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                            ('TOPPADDING', (0, 0), (-1, -1), 8),
                            ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                        ]
                        
                        # Color code YoY changes
                        for i in range(1, len(fin_data)):
                            yoy_text = fin_data[i][2]
                            if yoy_text.startswith('+'):
                                fin_style.append(('TEXTCOLOR', (2, i), (2, i), 
                                                reportlab_colors.HexColor(self.color_positive)))
                                fin_style.append(('FONTNAME', (2, i), (2, i), 'Helvetica-Bold'))
                            elif yoy_text.startswith('-'):
                                fin_style.append(('TEXTCOLOR', (2, i), (2, i), 
                                                reportlab_colors.HexColor(self.color_negative)))
                                fin_style.append(('FONTNAME', (2, i), (2, i), 'Helvetica-Bold'))
                        
                        # Apply the table style
                        fin_table.setStyle(TableStyle(fin_style))
                        
                        elements.append(fin_table)
                    else:
                        elements.append(Paragraph("Detailed financial metrics not available", self.body_style))
                    
                    # Add a financial health assessment if we have enough data
                    if latest_report:
                        elements.append(Spacer(1, 0.2*inch))
                        elements.append(Paragraph("Financial Health Assessment", self.section_style))
                        
                        # Extract key financial ratios for analysis
                        revenue = self._parse_financial_metric(latest_report, "revenues")
                        net_income = self._parse_financial_metric(latest_report, "net_income")
                        assets = self._parse_financial_metric(latest_report, "assets")
                        liabilities = self._parse_financial_metric(latest_report, "liabilities")
                        
                        assessment_points = []
                        
                        # Profitability assessment
                        if revenue is not None and net_income is not None and revenue > 0:
                            profit_margin = (net_income / revenue) * 100
                            if profit_margin > 15:
                                assessment_points.append(f"<b>Profitability:</b> Excellent - With a profit margin of {profit_margin:.2f}%, the company demonstrates strong profitability, well above industry averages.")
                            elif profit_margin > 10:
                                assessment_points.append(f"<b>Profitability:</b> Good - With a profit margin of {profit_margin:.2f}%, the company shows healthy profitability.")
                            elif profit_margin > 5:
                                assessment_points.append(f"<b>Profitability:</b> Moderate - The profit margin of {profit_margin:.2f}% is acceptable but leaves room for improvement.")
                            elif profit_margin > 0:
                                assessment_points.append(f"<b>Profitability:</b> Low - The profit margin of {profit_margin:.2f}% indicates minimal profitability.")
                            else:
                                assessment_points.append(f"<b>Profitability:</b> Concerning - The company is operating at a loss with a profit margin of {profit_margin:.2f}%.")
                        
                        # Balance sheet health
                        if assets is not None and liabilities is not None and assets > 0:
                            debt_to_assets = (liabilities / assets) * 100
                            if debt_to_assets < 30:
                                assessment_points.append(f"<b>Balance Sheet:</b> Very Strong - With debt at only {debt_to_assets:.2f}% of assets, the company has a conservative financial structure.")
                            elif debt_to_assets < 50:
                                assessment_points.append(f"<b>Balance Sheet:</b> Strong - With debt at {debt_to_assets:.2f}% of assets, the company maintains a healthy balance sheet.")
                            elif debt_to_assets < 70:
                                assessment_points.append(f"<b>Balance Sheet:</b> Moderate - With debt at {debt_to_assets:.2f}% of assets, the balance sheet is reasonable but has elevated leverage.")
                            else:
                                assessment_points.append(f"<b>Balance Sheet:</b> Leveraged - With debt at {debt_to_assets:.2f}% of assets, the company has high leverage that may pose financial risks.")
                        
                        # Add the assessment
                        if assessment_points:
                            for point in assessment_points:
                                elements.append(Paragraph(point, self.body_style))
                                elements.append(Spacer(1, 0.1*inch))
                        else:
                            elements.append(Paragraph("Insufficient data to provide a detailed financial health assessment.", self.body_style))
            else:
                elements.append(Paragraph("Financial data not available", self.body_style))
            
            # Add SEC filings information if available
            try:
                if self.data.get('sec_edgar_filings') and self.data['sec_edgar_filings'].get('company_filings'):
                    elements.append(Spacer(1, 0.2*inch))
                    elements.append(Paragraph("Recent SEC Filings", self.section_style))
                    
                    sec_data = self.data['sec_edgar_filings']['company_filings']
                    
                    # Extract filings data, handling different possible structures
                    recent_filings = []
                    
                    # Debug: log the structure to understand what we're dealing with
                    logger.info(f"SEC filings data structure type: {type(sec_data)}")
                    
                    # Try different possible paths to get filings data
                    if isinstance(sec_data.get('filings'), dict) and isinstance(sec_data['filings'].get('recent'), list):
                        recent_filings = sec_data['filings']['recent']
                        logger.info("Found filings in sec_data['filings']['recent']")
                    elif isinstance(sec_data.get('filings'), list):
                        recent_filings = sec_data['filings']
                        logger.info("Found filings in sec_data['filings']")
                    elif isinstance(sec_data.get('recent'), list):
                        recent_filings = sec_data['recent']
                        logger.info("Found filings in sec_data['recent']")
                    else:
                        # Try to extract any list that might contain filing data
                        for key, value in sec_data.items():
                            if isinstance(value, list) and len(value) > 0 and isinstance(value[0], dict):
                                if 'form' in value[0] or 'filing_date' in value[0] or 'filingDate' in value[0]:
                                    recent_filings = value
                                    logger.info(f"Found filings in sec_data['{key}']")
                                    break
                    
                    # If we found filings data
                    if recent_filings:
                        logger.info(f"Found {len(recent_filings)} SEC filings")
                        
                        # Limit to the 5 most recent filings if we have a list
                        filings_to_show = recent_filings[:5] if len(recent_filings) > 5 else recent_filings
                        
                        filing_data = [
                            ["Form", "Description", "Filing Date"]
                        ]
                        
                        for filing in filings_to_show:
                            if not isinstance(filing, dict):
                                logger.warning(f"Unexpected filing data type: {type(filing)}")
                                continue
                                
                            form = filing.get('form', 'N/A')
                            description = filing.get('description', 'N/A')
                            filed_date = filing.get('filingDate', filing.get('filing_date', 'N/A'))
                            
                            filing_data.append([form, description, filed_date])
                        
                        if len(filing_data) > 1:  # If we have actual data beyond headers
                            filing_table = Table(filing_data, colWidths=[1*inch, 4*inch, 1*inch])
                            
                            # Define improved table styling
                            filing_style = [
                                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_secondary)),
                                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                                ('ALIGN', (0, 1), (0, -1), 'LEFT'),
                                ('ALIGN', (2, 1), (2, -1), 'CENTER'),
                                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                ('FONTSIZE', (0, 0), (-1, 0), 11),
                                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                                ('TOPPADDING', (0, 0), (-1, -1), 8),
                                ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                            ]
                            
                            # Apply the table style
                            filing_table.setStyle(TableStyle(filing_style))
                            
                            elements.append(filing_table)
                        else:
                            elements.append(Paragraph("Could not extract SEC filing details", self.body_style))
                    else:
                        elements.append(Paragraph("No recent SEC filings available", self.body_style))
            except Exception as e:
                logger.error(f"Error processing SEC filings: {str(e)}")
                elements.append(Paragraph(f"Error processing SEC filings data: {str(e)}", self.body_style))
        
        except Exception as e:
            logger.error(f"Error creating financial highlights: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph(f"Error processing financial data: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _parse_financial_value(self, value_str):
        """Parse a financial value string and return the numeric value."""
        try:
            # Strip any currency symbols and commas
            cleaned = value_str.replace('$', '').replace(',', '')
            
            # Handle B/M/K suffixes
            if 'B' in cleaned:
                return float(cleaned.replace('B', '')) * 1_000_000_000
            elif 'M' in cleaned:
                return float(cleaned.replace('M', '')) * 1_000_000
            elif 'K' in cleaned:
                return float(cleaned.replace('K', '')) * 1_000
            else:
                return float(cleaned)
        except (ValueError, AttributeError):
            return 0
    
    def _extract_financial_metric(self, report, metric_name):
        """Extract a financial metric from the report and format it appropriately."""
        try:
            # Financial data might be nested in different ways depending on the API response
            financials = report.get('financials', {})
            
            # Check if metric exists in any of the common financial statements
            for statement in ['income_statement', 'balance_sheet', 'cash_flow_statement']:
                if statement in financials and metric_name in financials[statement]:
                    value = financials[statement][metric_name]
                    
                    # Format the value based on its magnitude
                    if isinstance(value, (int, float)):
                        return self._format_financial_value(value)
            
            return "N/A"
        except Exception as e:
            logger.error(f"Error extracting financial metric {metric_name}: {str(e)}")
            return "N/A"
    
    def _format_financial_value(self, value):
        """Format financial values for better readability."""
        try:
            abs_value = abs(value)
            
            if abs_value >= 1_000_000_000:
                return f"${value / 1_000_000_000:.2f}B"
            elif abs_value >= 1_000_000:
                return f"${value / 1_000_000:.2f}M"
            elif abs_value >= 1_000:
                return f"${value / 1_000:.2f}K"
            else:
                return f"${value:.2f}"
        except Exception as e:
            logger.error(f"Error formatting financial value: {str(e)}")
            return "N/A"
    
    def _format_number(self, value):
        """Format large numbers for better readability."""
        try:
            if not isinstance(value, (int, float)):
                return value
            
            abs_value = abs(value)
            
            if abs_value >= 1_000_000_000:
                return f"{value / 1_000_000_000:.2f}B"
            elif abs_value >= 1_000_000:
                return f"{value / 1_000_000:.2f}M"
            elif abs_value >= 1_000:
                return f"{value / 1_000:.2f}K"
            else:
                return f"{value:.2f}"
        except Exception as e:
            logger.error(f"Error formatting number: {str(e)}")
            return value
    
    def _create_news_summary(self):
        """Create the news summary section."""
        elements = []
        
        try:
            # Check if news data is available
            if not self.data.get('news'):
                elements.append(Paragraph("No recent news available", self.body_style))
                return elements
            
            news = self.data['news']
            
            # Limit to 5 most recent news items
            recent_news = news[:5] if news else []
            
            if recent_news:
                # Create a nicer card-style layout for each news item
                for i, article in enumerate(recent_news):
                    try:
                        title = article.get('title', 'No title available')
                        
                        # Safely get the published date with error handling
                        published_date = "Unknown date"
                        try:
                            published_utc = article.get('published_utc')
                            if published_utc and isinstance(published_utc, (int, float)):
                                published_date = datetime.fromtimestamp(published_utc).strftime('%Y-%m-%d')
                            elif published_utc and isinstance(published_utc, str):
                                # Try to parse string date
                                if published_utc.isdigit():
                                    published_date = datetime.fromtimestamp(int(published_utc)).strftime('%Y-%m-%d')
                                else:
                                    # Try different date formats
                                    date_formats = ['%Y-%m-%d', '%Y/%m/%d', '%d-%m-%Y', '%d/%m/%Y']
                                    for fmt in date_formats:
                                        try:
                                            published_date = datetime.strptime(published_utc, fmt).strftime('%Y-%m-%d')
                                            break
                                        except ValueError:
                                            continue
                        except Exception as e:
                            logger.warning(f"Error parsing news date: {str(e)}")
                        
                        # Safely get publisher name
                        publisher = article.get('publisher', {})
                        if isinstance(publisher, dict):
                            source = publisher.get('name', 'Unknown source')
                        else:
                            source = 'Unknown source'
                        
                        article_url = article.get('article_url', '#')
                        
                        # Create a news card with nicer styling
                        news_table_data = [
                            [Paragraph(f"<b>{title}</b>", self.section_style)]
                        ]
                        
                        meta_text = f"<i>{published_date} | {source}</i>"
                        news_table_data.append([Paragraph(meta_text, self.small_style)])
                        
                        # Add summary if available
                        if article.get('description'):
                            description = article['description']
                            # Limit description length if too long
                            if len(description) > 300:
                                description = description[:297] + "..."
                            news_table_data.append([Paragraph(description, self.body_style)])
                        
                        # Add source link
                        news_table_data.append([Paragraph(f"Source: {article_url}", self.small_style)])
                        
                        # Create the news card table
                        news_card = Table(news_table_data, colWidths=[6*inch])
                        
                        # Style the news card
                        news_card.setStyle(TableStyle([
                            ('BOX', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                            ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor('#F5F5F5')),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                            ('TOPPADDING', (0, 0), (-1, -1), 10),
                            ('LEFTPADDING', (0, 0), (-1, -1), 15),
                            ('RIGHTPADDING', (0, 0), (-1, -1), 15),
                        ]))
                        
                        elements.append(news_card)
                        elements.append(Spacer(1, 0.15*inch))
                    except Exception as e:
                        logger.error(f"Error processing news article: {str(e)}")
                        continue
            else:
                elements.append(Paragraph("No recent news available", self.body_style))
                
            # Add a sentiment analysis if available
            if recent_news and len(recent_news) > 0:
                elements.append(Spacer(1, 0.2*inch))
                elements.append(Paragraph("News Sentiment Analysis", self.section_style))
                
                # Basic sentiment analysis based on keywords in titles and descriptions
                positive_keywords = [
                    'rise', 'up', 'gain', 'positive', 'profit', 'growth', 'rally', 'surge', 
                    'increase', 'beat', 'exceed', 'outperform', 'upgrade', 'strong', 'bullish'
                ]
                
                negative_keywords = [
                    'fall', 'down', 'drop', 'negative', 'loss', 'decline', 'sink', 'plunge', 
                    'decrease', 'miss', 'underperform', 'downgrade', 'weak', 'bearish'
                ]
                
                positive_count = 0
                negative_count = 0
                total_analyzed = 0
                
                for article in recent_news:
                    title = article.get('title', '').lower()
                    description = article.get('description', '').lower()
                    
                    # Count keyword matches
                    for keyword in positive_keywords:
                        if keyword in title or keyword in description:
                            positive_count += 1
                            break
                    
                    for keyword in negative_keywords:
                        if keyword in title or keyword in description:
                            negative_count += 1
                            break
                    
                    total_analyzed += 1
                
                # Generate sentiment score (-100 to +100)
                if total_analyzed > 0:
                    sentiment_score = ((positive_count - negative_count) / total_analyzed) * 100
                    
                    # Generate sentiment analysis text
                    if sentiment_score > 50:
                        sentiment_text = f"The recent news sentiment is strongly positive (score: {sentiment_score:.1f}), which may indicate positive market perception of {self.ticker}."
                        sentiment_color = self.color_positive
                    elif sentiment_score > 20:
                        sentiment_text = f"The recent news sentiment is moderately positive (score: {sentiment_score:.1f}), suggesting favorable coverage for {self.ticker}."
                        sentiment_color = self.color_positive
                    elif sentiment_score > -20:
                        sentiment_text = f"The recent news sentiment is neutral (score: {sentiment_score:.1f}), with balanced positive and negative coverage of {self.ticker}."
                        sentiment_color = self.color_neutral
                    elif sentiment_score > -50:
                        sentiment_text = f"The recent news sentiment is moderately negative (score: {sentiment_score:.1f}), indicating some concerning coverage for {self.ticker}."
                        sentiment_color = self.color_negative
                    else:
                        sentiment_text = f"The recent news sentiment is strongly negative (score: {sentiment_score:.1f}), which might reflect significant challenges facing {self.ticker}."
                        sentiment_color = self.color_negative
                    
                    # Create sentiment box
                    sentiment_box = Table([[Paragraph(sentiment_text, self.body_style)]], colWidths=[6*inch])
                    sentiment_box.setStyle(TableStyle([
                        ('BOX', (0, 0), (-1, -1), 1, reportlab_colors.HexColor(sentiment_color)),
                        ('BACKGROUND', (0, 0), (-1, -1), reportlab_colors.HexColor(sentiment_color + '15')),  # Light background
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                        ('TOPPADDING', (0, 0), (-1, -1), 10),
                        ('LEFTPADDING', (0, 0), (-1, -1), 15),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 15),
                    ]))
                    
                    elements.append(sentiment_box)
                else:
                    elements.append(Paragraph("Insufficient news data for sentiment analysis.", self.body_style))
        
        except Exception as e:
            logger.error(f"Error creating news summary: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph(f"Error processing news data: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _parse_financial_metric(self, report, metric_name):
        """Parse a financial metric and return the numeric value."""
        try:
            # Financial data might be nested in different ways depending on the API response
            financials = report.get('financials', {})
            
            # Check if metric exists in any of the common financial statements
            for statement in ['income_statement', 'balance_sheet', 'cash_flow_statement']:
                if statement in financials and metric_name in financials[statement]:
                    value = financials[statement][metric_name]
                    
                    # If value is a dictionary, try to extract a numeric value from it
                    if isinstance(value, dict):
                        # Try common keys that might contain the actual value
                        for key in ['value', 'amount', 'total', 'raw']:
                            if key in value and isinstance(value[key], (int, float)):
                                return value[key]
                        # If no known keys, just return the first numeric value found
                        for val in value.values():
                            if isinstance(val, (int, float)):
                                return val
                        return None
                    elif isinstance(value, (int, float)):
                        return value
            
            return None
        except Exception as e:
            logger.error(f"Error parsing financial metric {metric_name}: {str(e)}")
            return None

    def _create_financial_highlights(self):
        """Create the financial highlights section."""
        elements = []
        
        try:
            # Check if financial data is available
            if not self.data.get('financials'):
                elements.append(Paragraph("No financial data available", self.body_style))
                return elements
            
            financials = self.data['financials']
            
            # Prepare financial metrics table
            if financials:
                # Get the latest financial report
                latest_report = financials[0] if financials else None
                
                if latest_report:
                    report_date = latest_report.get('filing_date', 'N/A')
                    
                    elements.append(Paragraph(f"Latest Financial Data (as of {report_date})", self.section_style))
                    
                    # Extract key financial metrics
                    fin_data = [
                        ["Metric", "Value", "YoY Change"]
                    ]
                    
                    # Try to extract common financial metrics
                    fin_metrics = [
                        ("Revenue", self._extract_financial_metric(latest_report, "revenues")),
                        ("Net Income", self._extract_financial_metric(latest_report, "net_income")),
                        ("EPS", self._extract_financial_metric(latest_report, "eps_basic")),
                        ("Total Assets", self._extract_financial_metric(latest_report, "assets")),
                        ("Total Liabilities", self._extract_financial_metric(latest_report, "liabilities")),
                        ("Cash & Equivalents", self._extract_financial_metric(latest_report, "cash_and_equivalents")),
                    ]
                    
                    # Add year-over-year changes if we have enough historical data
                    if len(financials) > 4:  # Assuming quarterly reports, need at least 5 for YoY comparison
                        yoy_report = None
                        for report in financials:
                            # Find report from approximately 1 year ago
                            report_date = report.get('filing_date')
                            latest_date = latest_report.get('filing_date')
                            
                            if report_date and latest_date:
                                try:
                                    report_dt = datetime.strptime(report_date, '%Y-%m-%d')
                                    latest_dt = datetime.strptime(latest_date, '%Y-%m-%d')
                                    days_diff = (latest_dt - report_dt).days
                                    
                                    if 350 <= days_diff <= 380:  # Approximately 1 year
                                        yoy_report = report
                                        break
                                except ValueError:
                                    pass
                        
                        # Add all available metrics with YoY changes
                        for metric, value in fin_metrics:
                            yoy_value = "N/A"
                            yoy_change = "N/A"
                            
                            if yoy_report:
                                # Extract YoY comparison for this metric
                                metric_key = metric.lower().replace(' ', '_').replace('&', 'and')
                                yoy_value = self._extract_financial_metric(yoy_report, metric_key)
                                
                                # Calculate YoY change if possible
                                if value != "N/A" and yoy_value != "N/A":
                                    # Extract numeric values
                                    try:
                                        current_val = self._parse_financial_value(value)
                                        past_val = self._parse_financial_value(yoy_value)
                                        
                                        if past_val != 0:
                                            pct_change = (current_val - past_val) / past_val * 100
                                            sign = "+" if pct_change >= 0 else ""
                                            yoy_change = f"{sign}{pct_change:.2f}%"
                                    except:
                                        yoy_change = "N/A"
                            
                            fin_data.append([metric, value, yoy_change])
                    else:
                        # Add metrics without YoY changes
                        for metric, value in fin_metrics:
                            if value != "N/A":
                                fin_data.append([metric, value, "N/A"])
                    
                    # Create the table with improved styling
                    if len(fin_data) > 1:  # If we have data beyond headers
                        fin_table = Table(fin_data, colWidths=[2.5*inch, 2*inch, 1.5*inch])
                        
                        # Define improved table styling
                        fin_style = [
                            ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                            ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                            ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                            ('ALIGN', (1, 0), (2, -1), 'RIGHT'),
                            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                            ('FONTSIZE', (0, 0), (-1, 0), 12),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                            ('TOPPADDING', (0, 0), (-1, -1), 8),
                            ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                        ]
                        
                        # Color code YoY changes
                        for i in range(1, len(fin_data)):
                            if i < len(fin_data):  # Safety check
                                yoy_text = fin_data[i][2] if len(fin_data[i]) > 2 else ""
                                if isinstance(yoy_text, str) and yoy_text.startswith('+'):
                                    fin_style.append(('TEXTCOLOR', (2, i), (2, i), 
                                                    reportlab_colors.HexColor(self.color_positive)))
                                    fin_style.append(('FONTNAME', (2, i), (2, i), 'Helvetica-Bold'))
                                elif isinstance(yoy_text, str) and yoy_text.startswith('-'):
                                    fin_style.append(('TEXTCOLOR', (2, i), (2, i), 
                                                    reportlab_colors.HexColor(self.color_negative)))
                                    fin_style.append(('FONTNAME', (2, i), (2, i), 'Helvetica-Bold'))
                        
                        # Apply the table style
                        fin_table.setStyle(TableStyle(fin_style))
                        
                        elements.append(fin_table)
                    else:
                        elements.append(Paragraph("Detailed financial metrics not available", self.body_style))
                    
                    # Add a financial health assessment if we have enough data
                    if latest_report:
                        elements.append(Spacer(1, 0.2*inch))
                        elements.append(Paragraph("Financial Health Assessment", self.section_style))
                        
                        # Extract key financial ratios for analysis - ensure we get numeric values
                        revenue = self._parse_financial_metric(latest_report, "revenues")
                        net_income = self._parse_financial_metric(latest_report, "net_income")
                        assets = self._parse_financial_metric(latest_report, "assets")
                        liabilities = self._parse_financial_metric(latest_report, "liabilities")
                        
                        assessment_points = []
                        
                        # Profitability assessment - with proper type checking
                        if isinstance(revenue, (int, float)) and isinstance(net_income, (int, float)) and revenue > 0:
                            profit_margin = (net_income / revenue) * 100
                            if profit_margin > 15:
                                assessment_points.append(f"<b>Profitability:</b> Excellent - With a profit margin of {profit_margin:.2f}%, the company demonstrates strong profitability, well above industry averages.")
                            elif profit_margin > 10:
                                assessment_points.append(f"<b>Profitability:</b> Good - With a profit margin of {profit_margin:.2f}%, the company shows healthy profitability.")
                            elif profit_margin > 5:
                                assessment_points.append(f"<b>Profitability:</b> Moderate - The profit margin of {profit_margin:.2f}% is acceptable but leaves room for improvement.")
                            elif profit_margin > 0:
                                assessment_points.append(f"<b>Profitability:</b> Low - The profit margin of {profit_margin:.2f}% indicates minimal profitability.")
                            else:
                                assessment_points.append(f"<b>Profitability:</b> Concerning - The company is operating at a loss with a profit margin of {profit_margin:.2f}%.")
                        
                        # Balance sheet health - with proper type checking
                        if isinstance(assets, (int, float)) and isinstance(liabilities, (int, float)) and assets > 0:
                            debt_to_assets = (liabilities / assets) * 100
                            if debt_to_assets < 30:
                                assessment_points.append(f"<b>Balance Sheet:</b> Very Strong - With debt at only {debt_to_assets:.2f}% of assets, the company has a conservative financial structure.")
                            elif debt_to_assets < 50:
                                assessment_points.append(f"<b>Balance Sheet:</b> Strong - With debt at {debt_to_assets:.2f}% of assets, the company maintains a healthy balance sheet.")
                            elif debt_to_assets < 70:
                                assessment_points.append(f"<b>Balance Sheet:</b> Moderate - With debt at {debt_to_assets:.2f}% of assets, the balance sheet is reasonable but has elevated leverage.")
                            else:
                                assessment_points.append(f"<b>Balance Sheet:</b> Leveraged - With debt at {debt_to_assets:.2f}% of assets, the company has high leverage that may pose financial risks.")
                        
                        # Add the assessment
                        if assessment_points:
                            for point in assessment_points:
                                elements.append(Paragraph(point, self.body_style))
                                elements.append(Spacer(1, 0.1*inch))
                        else:
                            elements.append(Paragraph("Insufficient data to provide a detailed financial health assessment.", self.body_style))
            else:
                elements.append(Paragraph("Financial data not available", self.body_style))
            
            # Add SEC filings information if available
            try:
                if self.data.get('sec_edgar_filings') and self.data['sec_edgar_filings'].get('company_filings'):
                    elements.append(Spacer(1, 0.2*inch))
                    elements.append(Paragraph("Recent SEC Filings", self.section_style))
                    
                    sec_data = self.data['sec_edgar_filings']['company_filings']
                    
                    # Extract filings data, handling different possible structures
                    recent_filings = []
                    
                    # Debug: log the structure to understand what we're dealing with
                    logger.info(f"SEC filings data structure type: {type(sec_data)}")
                    
                    # Try different possible paths to get filings data
                    if isinstance(sec_data.get('filings'), dict) and isinstance(sec_data['filings'].get('recent'), list):
                        recent_filings = sec_data['filings']['recent']
                        logger.info("Found filings in sec_data['filings']['recent']")
                    elif isinstance(sec_data.get('filings'), list):
                        recent_filings = sec_data['filings']
                        logger.info("Found filings in sec_data['filings']")
                    elif isinstance(sec_data.get('recent'), list):
                        recent_filings = sec_data['recent']
                        logger.info("Found filings in sec_data['recent']")
                    else:
                        # Try to extract any list that might contain filing data
                        for key, value in sec_data.items():
                            if isinstance(value, list) and len(value) > 0 and isinstance(value[0], dict):
                                if 'form' in value[0] or 'filing_date' in value[0] or 'filingDate' in value[0]:
                                    recent_filings = value
                                    logger.info(f"Found filings in sec_data['{key}']")
                                    break
                    
                    # If we found filings data
                    if recent_filings:
                        logger.info(f"Found {len(recent_filings)} SEC filings")
                        
                        # Limit to the 5 most recent filings if we have a list
                        filings_to_show = recent_filings[:5] if len(recent_filings) > 5 else recent_filings
                        
                        filing_data = [
                            ["Form", "Description", "Filing Date"]
                        ]
                        
                        for filing in filings_to_show:
                            if not isinstance(filing, dict):
                                logger.warning(f"Unexpected filing data type: {type(filing)}")
                                continue
                                
                            form = filing.get('form', 'N/A')
                            description = filing.get('description', 'N/A')
                            filed_date = filing.get('filingDate', filing.get('filing_date', 'N/A'))
                            
                            filing_data.append([form, description, filed_date])
                        
                        if len(filing_data) > 1:  # If we have actual data beyond headers
                            filing_table = Table(filing_data, colWidths=[1*inch, 4*inch, 1*inch])
                            
                            # Define improved table styling
                            filing_style = [
                                ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                                ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_secondary)),
                                ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                                ('ALIGN', (0, 1), (0, -1), 'LEFT'),
                                ('ALIGN', (2, 1), (2, -1), 'CENTER'),
                                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                                ('FONTSIZE', (0, 0), (-1, 0), 11),
                                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                                ('TOPPADDING', (0, 0), (-1, -1), 8),
                                ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                            ]
                            
                            # Apply the table style
                            filing_table.setStyle(TableStyle(filing_style))
                            
                            elements.append(filing_table)
                        else:
                            elements.append(Paragraph("Could not extract SEC filing details", self.body_style))
                    else:
                        elements.append(Paragraph("No recent SEC filings available", self.body_style))
            except Exception as e:
                logger.error(f"Error processing SEC filings: {str(e)}")
                elements.append(Paragraph(f"Error processing SEC filings data: {str(e)}", self.body_style))
        
        except Exception as e:
            logger.error(f"Error creating financial highlights: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph(f"Error processing financial data: {str(e)}", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
        
    def _create_dividend_analysis(self):
        """Create the dividend analysis section."""
        elements = []
        
        try:
            dividends = self.data.get('dividends', [])
            
            if not dividends:
                elements.append(Paragraph("No dividend data available", self.body_style))
                return elements
            
            # Get the most recent dividend
            latest_dividend = dividends[0] if dividends else None
            
            if latest_dividend:
                # Extract dividend information
                ex_date = latest_dividend.get('ex_dividend_date', 'N/A')
                pay_date = latest_dividend.get('pay_date', 'N/A')
                
                try:
                    dividend_amount = float(latest_dividend.get('cash_amount', 0))
                except (ValueError, TypeError):
                    dividend_amount = 0
                
                # Create dividend summary with enhanced styling
                elements.append(Paragraph("Latest Dividend Information", self.section_style))
                
                div_data = [
                    ["Metric", "Value"],
                    ["Ex-Dividend Date", ex_date],
                    ["Payment Date", pay_date],
                    ["Dividend Amount", f"${dividend_amount:.4f}" if dividend_amount else 'N/A'],
                ]
                
                # Add dividend yield if we can calculate it
                annual_yield = None
                if self.data.get('recent_aggregates') and dividend_amount:
                    try:
                        latest_price = float(self.data['recent_aggregates'][-1]['c'])
                        if latest_price > 0:
                            # Determine frequency based on data
                            if len(dividends) >= 2:
                                try:
                                    # Get dates of last two dividends
                                    date1 = datetime.strptime(dividends[0].get('pay_date', ''), '%Y-%m-%d')
                                    date2 = datetime.strptime(dividends[1].get('pay_date', ''), '%Y-%m-%d')
                                    days_between = abs((date1 - date2).days)
                                    
                                    # Estimate frequency
                                    if days_between < 40:  # Monthly
                                        freq_multiplier = 12
                                        freq_text = "monthly"
                                    elif days_between < 100:  # Quarterly
                                        freq_multiplier = 4
                                        freq_text = "quarterly"
                                    elif days_between < 200:  # Semi-annual
                                        freq_multiplier = 2
                                        freq_text = "semi-annual"
                                    else:  # Annual
                                        freq_multiplier = 1
                                        freq_text = "annual"
                                except (ValueError, TypeError):
                                    # Default to quarterly if can't determine
                                    freq_multiplier = 4
                                    freq_text = "quarterly"
                            else:
                                # Default to quarterly if only one dividend
                                freq_multiplier = 4
                                freq_text = "quarterly"
                            
                            # Calculate annual yield
                            annual_yield = (dividend_amount * freq_multiplier) / latest_price * 100
                            
                            div_data.append([f"Est. Annual Yield ({freq_text})", f"{annual_yield:.2f}%"])
                    except (KeyError, ValueError, TypeError, IndexError) as e:
                        logger.warning(f"Could not calculate dividend yield: {str(e)}")
                
                # Enhanced dividend table
                div_table = Table(div_data, colWidths=[3*inch, 3*inch])
                div_table.setStyle(TableStyle([
                    ('GRID', (0, 0), (-1, -1), 0.5, reportlab_colors.lightgrey),
                    ('BACKGROUND', (0, 0), (-1, 0), reportlab_colors.HexColor(self.color_primary)),
                    ('BACKGROUND', (0, 1), (0, -1), reportlab_colors.HexColor('#F5F5F5')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), reportlab_colors.white),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                    ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 12),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                    ('TOPPADDING', (0, 0), (-1, -1), 8),
                ]))
                
                elements.append(div_table)
                
                # Add yield assessment if available
                if annual_yield is not None:
                    elements.append(Spacer(1, 0.2*inch))
                    elements.append(Paragraph("Dividend Yield Assessment", self.section_style))
                    
                    assessment_text = ""
                    if annual_yield > 6:
                        assessment_text = f"{self.ticker} offers a high dividend yield of {annual_yield:.2f}%, which is significantly above market averages. This may indicate higher income potential but could also suggest elevated risk or concerns about sustainability."
                    elif annual_yield > 3:
                        assessment_text = f"{self.ticker} provides an above-average dividend yield of {annual_yield:.2f}%, offering attractive income potential while maintaining reasonable balance between payouts and reinvestment."
                    elif annual_yield > 1.5:
                        assessment_text = f"{self.ticker} offers a moderate dividend yield of {annual_yield:.2f}%, which is in line with market averages. This suggests a balanced approach between returning cash to shareholders and retaining earnings for growth."
                    else:
                        assessment_text = f"{self.ticker} provides a modest dividend yield of {annual_yield:.2f}%, below market averages. This may indicate the company prioritizes reinvestment for growth over immediate shareholder returns."
                    
                    elements.append(Paragraph(assessment_text, self.body_style))
                
                # Create dividend history chart if we have multiple dividend records
                if len(dividends) > 1:
                    elements.append(Spacer(1, 0.2*inch))
                    elements.append(Paragraph("Dividend History", self.section_style))
                    
                    # Prepare data for chart
                    div_dates = []
                    div_dt_objects = []
                    div_amounts = []
                    
                    # Get up to 10 most recent dividends (in reverse to show oldest to newest)
                    for div in reversed(dividends[:10]):
                        div_date = div.get('pay_date', 'N/A')
                        
                        try:
                            div_amount = float(div.get('cash_amount', 0))
                        except (ValueError, TypeError):
                            div_amount = 0
                        
                        if div_date != 'N/A' and div_amount:
                            try:
                                # Convert string date to datetime object
                                dt_obj = datetime.strptime(div_date, '%Y-%m-%d')
                                div_dt_objects.append(dt_obj)
                                div_dates.append(div_date)
                                div_amounts.append(div_amount)
                            except ValueError:
                                logger.warning(f"Could not parse dividend date: {div_date}")
                    
                    if div_dt_objects and div_amounts:
                        # Sort data points by date
                        data_points = sorted(zip(div_dt_objects, div_dates, div_amounts))
                        div_dt_objects = [point[0] for point in data_points]
                        div_dates = [point[1] for point in data_points]
                        div_amounts = [point[2] for point in data_points]
                        
                        # Create dividend history chart using matplotlib
                        fig, ax = plt.subplots(figsize=(10, 5))
                        
                        # Create a gradient colormap for bars
                        colors = plt.cm.Greens(np.linspace(0.5, 0.9, len(div_dt_objects)))
                        
                        # Add bar chart with enhanced styling
                        bars = ax.bar(div_dt_objects, div_amounts, color=colors, alpha=0.8, width=20)
                        ax.set_title(f"{self.ticker} - Dividend History", fontsize=16, fontweight='bold', color=self.color_primary)
                        ax.set_ylabel("Dividend Amount ($)", fontsize=12, fontweight='bold', color=self.color_primary)
                        ax.set_xlabel("Payment Date", fontsize=12, fontweight='bold', color=self.color_primary)
                        ax.grid(True, alpha=0.3, axis='y', linestyle='--')
                        ax.spines['top'].set_visible(False)
                        ax.spines['right'].set_visible(False)
                        
                        # Make the background lighter for better readability
                        ax.set_facecolor('#F8F9F9')
                        
                        # Add data labels on top of each bar
                        for i, bar in enumerate(bars):
                            height = bar.get_height()
                            ax.text(
                                bar.get_x() + bar.get_width() / 2,
                                height + 0.0005,
                                f'${div_amounts[i]:.3f}',
                                ha='center',
                                va='bottom',
                                fontsize=9,
                                fontweight='bold',
                                rotation=45
                            )
                        
                        # Format y-axis as currency
                        ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'${x:.3f}'))
                        
                        # Format x-axis for cleaner date labels
                        date_fmt = mdates.DateFormatter('%b %Y')
                        ax.xaxis.set_major_formatter(date_fmt)
                        
                        # Use a custom locator to avoid crowded labels
                        locator = mdates.AutoDateLocator(minticks=4, maxticks=8)
                        ax.xaxis.set_major_locator(locator)
                        
                        # Rotate x-axis labels for better readability
                        plt.xticks(rotation=45, ha='right')
                        
                        # Add trend line if we have enough data
                        if len(div_amounts) > 2:
                            # Convert datetime to numerical values for trend line
                            x_nums = mdates.date2num(div_dt_objects)
                            z = np.polyfit(x_nums, div_amounts, 1)
                            p = np.poly1d(z)
                            
                            # Plot trend line
                            ax.plot(div_dt_objects, p(x_nums), "r--", alpha=0.7, linewidth=2, label='Trend')
                            
                            # Add legend
                            ax.legend(loc='upper left', frameon=True, facecolor='white', 
                                    edgecolor='lightgray', framealpha=0.9)
                            
                            # Add trend annotation - use text instead of emojis
                            trend_text = ""
                            if z[0] > 0.0005:  # Significant increase
                                trend_text = "Strong increasing dividend trend"
                                trend_color = self.color_positive
                            elif z[0] > 0.0001:  # Slight increase
                                trend_text = "Slight increasing dividend trend"
                                trend_color = self.color_positive
                            elif z[0] > -0.0001:  # Flat
                                trend_text = "Stable dividend trend"
                                trend_color = self.color_neutral
                            elif z[0] > -0.0005:  # Slight decrease
                                trend_text = "Slight decreasing dividend trend"
                                trend_color = self.color_negative
                            else:  # Significant decrease
                                trend_text = "Strong decreasing dividend trend"
                                trend_color = self.color_negative
                                
                            # Add a text box with the trend annotation
                            props = dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.8, edgecolor=trend_color)
                            ax.text(0.02, 0.95, trend_text, transform=ax.transAxes, fontsize=10,
                                verticalalignment='top', bbox=props, color=trend_color)
                        
                        # Adjust layout
                        plt.tight_layout()
                        
                        # Save to BytesIO with higher resolution
                        img_data = BytesIO()
                        plt.savefig(img_data, format='png', dpi=150, bbox_inches='tight')
                        img_data.seek(0)
                        plt.close()
                        
                        # Add image to PDF
                        image = Image(img_data, width=6.5*inch, height=3.5*inch)
                        elements.append(image)
                        
                        # Add dividend growth analysis if we have enough data
                        if len(div_amounts) > 2:
                            elements.append(Spacer(1, 0.2*inch))
                            elements.append(Paragraph("Dividend Growth Analysis", self.section_style))
                            
                            # Calculate year-over-year growth if possible
                            if len(div_amounts) >= 5:
                                # Consider dividends approximately 1 year apart
                                older_div = div_amounts[0]  # Oldest dividend in our dataset
                                newer_div = div_amounts[-1]  # Newest dividend
                                
                                # Calculate annualized growth rate
                                if older_div > 0:
                                    years_diff = (div_dt_objects[-1] - div_dt_objects[0]).days / 365.0
                                    if years_diff > 0:
                                        annual_growth_rate = ((newer_div / older_div) ** (1 / years_diff) - 1) * 100
                                        
                                        growth_text = ""
                                        if annual_growth_rate > 10:
                                            growth_text = f"The dividend has shown exceptional growth with an annualized rate of {annual_growth_rate:.2f}% over the analyzed period. This strong growth rate suggests the company has been significantly increasing its return of capital to shareholders."
                                        elif annual_growth_rate > 5:
                                            growth_text = f"The dividend has shown healthy growth with an annualized rate of {annual_growth_rate:.2f}% over the analyzed period. This solid growth rate indicates the company's commitment to increasing shareholder returns over time."
                                        elif annual_growth_rate > 0:
                                            growth_text = f"The dividend has shown modest growth with an annualized rate of {annual_growth_rate:.2f}% over the analyzed period. This positive growth rate suggests a stable dividend policy with gradual increases."
                                        elif annual_growth_rate > -5:
                                            growth_text = f"The dividend has shown a slight decline with an annualized rate of {annual_growth_rate:.2f}% over the analyzed period. This may indicate some challenges in maintaining dividend growth."
                                        else:
                                            growth_text = f"The dividend has shown a significant decline with an annualized rate of {annual_growth_rate:.2f}% over the analyzed period. This substantial decrease may signal financial challenges or a shift in capital allocation strategy."
                                        
                                        elements.append(Paragraph(growth_text, self.body_style))
                                    else:
                                        elements.append(Paragraph("Insufficient time span in dividend history to calculate meaningful growth rates.", self.body_style))
                            else:
                                elements.append(Paragraph("Insufficient dividend history to calculate long-term growth trends.", self.body_style))
            else:
                elements.append(Paragraph("No dividend information available", self.body_style))
            
        except Exception as e:
            logger.error(f"Error creating dividend analysis: {str(e)}\n{traceback.format_exc()}")
            elements.append(Paragraph("Error processing dividend data", self.body_style))
        
        elements.append(Spacer(1, 0.3*inch))
        
        return elements

if __name__ == "__main__":
    # Example usage
    ticker = "AAPL"  # Replace with desired ticker
    report_gen = StockReportGenerator(ticker)
    
    if report_gen.load_data():
        pdf_file = report_gen.generate_report()
        print(f"Report generated: {pdf_file}")
    else:
        print("Failed to load data. Make sure analyze_stock function has been run for this ticker.")